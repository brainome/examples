#!/usr/bin/env python3
#
# This code has been produced by a free evaluation version of Daimensions(tm).
# Portions of this code copyright (c) 2019, 2020 by Brainome, Inc. All Rights Reserved.
# Brainome grants an exclusive (subject to our continuing rights to use and modify models),
# worldwide, non-sublicensable, and non-transferable limited license to use and modify this
# predictor produced through the input of your data:
# (i) for users accessing the service through a free evaluation account, solely for your
# own non-commercial purposes, including for the purpose of evaluating this service, and
# (ii) for users accessing the service through a paid, commercial use account, for your
# own internal  and commercial purposes.
# Please contact support@brainome.ai with any questions.
# Use of predictions results at your own risk.
#
# Output of Brainome Daimensions(tm) 0.99 Table Compiler v0.99.
# Invocation: btc -v -v -f NN titanic_train.csv -o titanic_predict.py -target Survived --yes
# Total compiler execution time: 0:01:16.28. Finished on: Feb-24-2021 20:55:11.
# This source code requires Python 3.
#
"""
Classifier Type:                     Neural Network
System Type:                         Binary classifier
Training/Validation Split:           60:40%
Best-guess accuracy:                 61.61%
Training accuracy:                   63.67% (340/534 correct)
Validation accuracy:                 58.54% (209/357 correct)
Overall Model accuracy:              61.61% (549/891 correct)
Overall Improvement over best guess: 0.00% (of possible 38.39%)
Model capacity (MEC):                27 bits
Generalization ratio:                19.53 bits/bit
Model efficiency:                    0.00%/parameter
System behavior
True Negatives:                      61.62% (549/891)
True Positives:                      0.00% (0/891)
False Negatives:                     38.38% (342/891)
False Positives:                     0.00% (0/891)
True Pos. Rate/Sensitivity/Recall:   0.00
True Neg. Rate/Specificity:          1.00
F-1 Measure:                         0.00
False Negative Rate/Miss Rate:       1.00
Critical Success Index:              0.00
Confusion Matrix:
 [61.62% 0.00%]
 [38.38% 0.00%]
Generalization efficiency:           9.62
Overfitting:                         No
"""

# Imports -- Python3 standard library
import sys
import math
import os
import argparse
import tempfile
import csv
import binascii
import faulthandler

# Imports -- external
try:
    import numpy as np # For numpy see: http://numpy.org
    from numpy import array
except:
    print("This predictor requires the Numpy library. For installation instructions please refer to: http://numpy.org")

# Magic constants follow
# I/O buffer for clean. Reduce this constant for low memory devices. 
IOBUF = 100000000

# Ugly workaround for large classifiers
sys.setrecursionlimit(1000000)

# Training file given to compiler
TRAINFILE = "titanic_train.csv"


#Number of output logits
num_output_logits = 1

#Number of attributes
num_attr = 11
num_attr_before_transform = 0
n_classes = 2

mappings = [{7568205.0: 0, 31584634.0: 1, 42576353.0: 2, 46148864.0: 3, 47142849.0: 4, 54314093.0: 5, 57626876.0: 6, 64996403.0: 7, 77381512.0: 8, 78628398.0: 9, 80079269.0: 10, 81532804.0: 11, 85090796.0: 12, 93192376.0: 13, 118235023.0: 14, 127226114.0: 15, 130821016.0: 16, 154400732.0: 17, 163952900.0: 18, 166744854.0: 19, 168598342.0: 20, 169548517.0: 21, 179699946.0: 22, 182784763.0: 23, 184524800.0: 24, 189562860.0: 25, 202795242.0: 26, 211005299.0: 27, 219120582.0: 28, 235316829.0: 29, 243772764.0: 30, 245383305.0: 31, 247214272.0: 32, 254812758.0: 33, 260874570.0: 34, 262581854.0: 35, 263192209.0: 36, 265835777.0: 37, 266221762.0: 38, 291168064.0: 39, 291840353.0: 40, 291946478.0: 41, 302887826.0: 42, 309726259.0: 43, 314058818.0: 44, 316147293.0: 45, 321889009.0: 46, 330917215.0: 47, 342601119.0: 48, 351477173.0: 49, 357728528.0: 50, 368475082.0: 51, 381443777.0: 52, 390926465.0: 53, 394293822.0: 54, 398197133.0: 55, 398312075.0: 56, 411412684.0: 57, 413136638.0: 58, 424010434.0: 59, 444814115.0: 60, 447259131.0: 61, 461525811.0: 62, 480328980.0: 63, 487725997.0: 64, 492549098.0: 65, 521466456.0: 66, 552054844.0: 67, 562864511.0: 68, 568043780.0: 69, 571926002.0: 70, 587527195.0: 71, 598980242.0: 72, 607108351.0: 73, 611996828.0: 74, 616200519.0: 75, 626405523.0: 76, 630184763.0: 77, 633267719.0: 78, 638169461.0: 79, 640647026.0: 80, 651818029.0: 81, 652113630.0: 82, 664032782.0: 83, 666032754.0: 84, 676424683.0: 85, 707278448.0: 86, 710114708.0: 87, 713621597.0: 88, 715925995.0: 89, 721071986.0: 90, 725637966.0: 91, 726801728.0: 92, 728621895.0: 93, 735983868.0: 94, 761301754.0: 95, 775382424.0: 96, 776271183.0: 97, 784306920.0: 98, 791412853.0: 99, 797430897.0: 100, 800419425.0: 101, 803404132.0: 102, 814407337.0: 103, 814730450.0: 104, 822882782.0: 105, 826308219.0: 106, 830883095.0: 107, 839584246.0: 108, 867001224.0: 109, 878704550.0: 110, 884544095.0: 111, 885203757.0: 112, 888997673.0: 113, 902718237.0: 114, 926632272.0: 115, 932604740.0: 116, 935194175.0: 117, 948050452.0: 118, 948435440.0: 119, 949419471.0: 120, 950520290.0: 121, 952798687.0: 122, 973883956.0: 123, 990312558.0: 124, 990890389.0: 125, 1007102524.0: 126, 1007252054.0: 127, 1008744220.0: 128, 1025264601.0: 129, 1029256472.0: 130, 1036652301.0: 131, 1045467857.0: 132, 1057337568.0: 133, 1059378430.0: 134, 1063733101.0: 135, 1069137203.0: 136, 1086610079.0: 137, 1087855644.0: 138, 1092469386.0: 139, 1095095930.0: 140, 1106833238.0: 141, 1119319559.0: 142, 1134842973.0: 143, 1143190097.0: 144, 1151621436.0: 145, 1190027195.0: 146, 1219787949.0: 147, 1246734695.0: 148, 1254950831.0: 149, 1266003089.0: 150, 1270904140.0: 151, 1271516607.0: 152, 1296350589.0: 153, 1299857053.0: 154, 1301042352.0: 155, 1301446449.0: 156, 1301645283.0: 157, 1310197159.0: 158, 1321523858.0: 159, 1324672308.0: 160, 1340514019.0: 161, 1350557248.0: 162, 1361638124.0: 163, 1365649653.0: 164, 1407539607.0: 165, 1416621426.0: 166, 1417337603.0: 167, 1423247034.0: 168, 1433586643.0: 169, 1436701435.0: 170, 1439395747.0: 171, 1447273056.0: 172, 1459795196.0: 173, 1474857972.0: 174, 1475894241.0: 175, 1477956724.0: 176, 1488262034.0: 177, 1492634435.0: 178, 1498426941.0: 179, 1519320231.0: 180, 1550413855.0: 181, 1553097459.0: 182, 1567661958.0: 183, 1580445374.0: 184, 1581832591.0: 185, 1596714761.0: 186, 1607749018.0: 187, 1609141782.0: 188, 1619055906.0: 189, 1626148750.0: 190, 1634394734.0: 191, 1634622650.0: 192, 1642103816.0: 193, 1655319892.0: 194, 1658551845.0: 195, 1660475624.0: 196, 1680211565.0: 197, 1686850523.0: 198, 1695641750.0: 199, 1701952386.0: 200, 1707542237.0: 201, 1711447443.0: 202, 1715177264.0: 203, 1722863343.0: 204, 1725499819.0: 205, 1726978720.0: 206, 1741264503.0: 207, 1743526938.0: 208, 1745885093.0: 209, 1786334035.0: 210, 1805167917.0: 211, 1812200471.0: 212, 1815406247.0: 213, 1825455679.0: 214, 1828404430.0: 215, 1831247109.0: 216, 1831396227.0: 217, 1831753942.0: 218, 1833103103.0: 219, 1837339931.0: 220, 1840275563.0: 221, 1848989653.0: 222, 1857659989.0: 223, 1893658678.0: 224, 1902230793.0: 225, 1928929480.0: 226, 1932509916.0: 227, 1938919316.0: 228, 1940754699.0: 229, 1952426809.0: 230, 1966046407.0: 231, 1966436607.0: 232, 1969103437.0: 233, 1973158402.0: 234, 1980844827.0: 235, 1982336853.0: 236, 1985963002.0: 237, 1986814500.0: 238, 1995090729.0: 239, 1998673901.0: 240, 2000729340.0: 241, 2013771093.0: 242, 2022992951.0: 243, 2024081778.0: 244, 2043834114.0: 245, 2045887405.0: 246, 2047141282.0: 247, 2048885147.0: 248, 2056300502.0: 249, 2059165479.0: 250, 2060605592.0: 251, 2067117955.0: 252, 2071382355.0: 253, 2076767461.0: 254, 2076926823.0: 255, 2079814588.0: 256, 2084583722.0: 257, 2092156651.0: 258, 2097376901.0: 259, 2100484476.0: 260, 2111635874.0: 261, 2112022397.0: 262, 2112859230.0: 263, 2122042453.0: 264, 2122439704.0: 265, 2136063713.0: 266, 2136275593.0: 267, 2144171404.0: 268, 2147604008.0: 269, 2154392799.0: 270, 2163316569.0: 271, 2165889405.0: 272, 2172181622.0: 273, 2182173664.0: 274, 2185858860.0: 275, 2186320972.0: 276, 2186731568.0: 277, 2196959547.0: 278, 2197506501.0: 279, 2209247357.0: 280, 2236963121.0: 281, 2248656298.0: 282, 2248952290.0: 283, 2251139637.0: 284, 2253398425.0: 285, 2259320270.0: 286, 2261887770.0: 287, 2263975024.0: 288, 2275571942.0: 289, 2278972177.0: 290, 2281078481.0: 291, 2281707240.0: 292, 2291835316.0: 293, 2292506568.0: 294, 2305833023.0: 295, 2315779141.0: 296, 2332636284.0: 297, 2361384658.0: 298, 2362733878.0: 299, 2370290050.0: 300, 2378364293.0: 301, 2390924590.0: 302, 2398449121.0: 303, 2408394837.0: 304, 2414100300.0: 305, 2420997509.0: 306, 2426523912.0: 307, 2442787868.0: 308, 2470944060.0: 309, 2487598861.0: 310, 2492151907.0: 311, 2503638742.0: 312, 2504300188.0: 313, 2518697729.0: 314, 2522760040.0: 315, 2533761181.0: 316, 2534801162.0: 317, 2535876195.0: 318, 2536976830.0: 319, 2544843289.0: 320, 2546160221.0: 321, 2546267626.0: 322, 2548412754.0: 323, 2552674861.0: 324, 2568243278.0: 325, 2575722337.0: 326, 2575861716.0: 327, 2578141282.0: 328, 2585503507.0: 329, 2591132975.0: 330, 2612142767.0: 331, 2628013397.0: 332, 2629381057.0: 333, 2631125237.0: 334, 2659339929.0: 335, 2679195729.0: 336, 2692542083.0: 337, 2697583696.0: 338, 2698940299.0: 339, 2709173643.0: 340, 2714931734.0: 341, 2716201483.0: 342, 2720216852.0: 343, 2722701995.0: 344, 2723101977.0: 345, 2724511835.0: 346, 2725355736.0: 347, 2727102322.0: 348, 2731521288.0: 349, 2734494787.0: 350, 2739365662.0: 351, 2740179695.0: 352, 2741810088.0: 353, 2743229579.0: 354, 2747823236.0: 355, 2758811665.0: 356, 2761104134.0: 357, 2775876818.0: 358, 2785347530.0: 359, 2790301988.0: 360, 2797468460.0: 361, 2799305643.0: 362, 2814953483.0: 363, 2830841925.0: 364, 2836229039.0: 365, 2851671639.0: 366, 2854209693.0: 367, 2855706057.0: 368, 2882958576.0: 369, 2897324890.0: 370, 2899861940.0: 371, 2926208450.0: 372, 2933910054.0: 373, 2948632979.0: 374, 2966647457.0: 375, 2970761842.0: 376, 2988691415.0: 377, 2994979786.0: 378, 3002512871.0: 379, 3004533744.0: 380, 3013572701.0: 381, 3021547039.0: 382, 3023899702.0: 383, 3026396312.0: 384, 3037480860.0: 385, 3040326561.0: 386, 3042192074.0: 387, 3049818100.0: 388, 3055036449.0: 389, 3055104456.0: 390, 3066297261.0: 391, 3079646614.0: 392, 3084659373.0: 393, 3094057672.0: 394, 3104767186.0: 395, 3105778646.0: 396, 3109894173.0: 397, 3117999570.0: 398, 3119222430.0: 399, 3125555732.0: 400, 3141765568.0: 401, 3150986110.0: 402, 3169745065.0: 403, 3190785943.0: 404, 3214473522.0: 405, 3219234252.0: 406, 3227055742.0: 407, 3229890433.0: 408, 3233166977.0: 409, 3240286110.0: 410, 3256973478.0: 411, 3257904832.0: 412, 3270236620.0: 413, 3272424860.0: 414, 3278032498.0: 415, 3283606073.0: 416, 3301486033.0: 417, 3307433958.0: 418, 3307630197.0: 419, 3314640593.0: 420, 3320116679.0: 421, 3324964693.0: 422, 3344631864.0: 423, 3362082684.0: 424, 3400401295.0: 425, 3415643144.0: 426, 3431451015.0: 427, 3443009281.0: 428, 3445644572.0: 429, 3450744125.0: 430, 3455018084.0: 431, 3458586278.0: 432, 3488348869.0: 433, 3507537456.0: 434, 3522291992.0: 435, 3542473769.0: 436, 3546401354.0: 437, 3548451260.0: 438, 3556230888.0: 439, 3558110733.0: 440, 3560043046.0: 441, 3563488140.0: 442, 3590178302.0: 443, 3596891736.0: 444, 3602573497.0: 445, 3602980435.0: 446, 3604501993.0: 447, 3608107920.0: 448, 3610894869.0: 449, 3625384694.0: 450, 3633315659.0: 451, 3650213175.0: 452, 3651434259.0: 453, 3658356772.0: 454, 3660700118.0: 455, 3664427134.0: 456, 3679254396.0: 457, 3685913228.0: 458, 3687200584.0: 459, 3691084712.0: 460, 3703330719.0: 461, 3717130270.0: 462, 3718979761.0: 463, 3725181329.0: 464, 3733928024.0: 465, 3735412249.0: 466, 3744897363.0: 467, 3765887291.0: 468, 3787659971.0: 469, 3792212560.0: 470, 3794252275.0: 471, 3805289591.0: 472, 3836682234.0: 473, 3841920890.0: 474, 3843532161.0: 475, 3843752893.0: 476, 3863845365.0: 477, 3890956855.0: 478, 3894182662.0: 479, 3898173052.0: 480, 3907091234.0: 481, 3909562909.0: 482, 3910734448.0: 483, 3912665389.0: 484, 3913921820.0: 485, 3933370039.0: 486, 3938546882.0: 487, 3938599210.0: 488, 3954414063.0: 489, 3960471853.0: 490, 3962247237.0: 491, 3967353484.0: 492, 3977465083.0: 493, 3980875730.0: 494, 3986926830.0: 495, 3988349364.0: 496, 3994297196.0: 497, 3998777726.0: 498, 4002166717.0: 499, 4006529924.0: 500, 4011691877.0: 501, 4015191757.0: 502, 4020368335.0: 503, 4041322540.0: 504, 4047515740.0: 505, 4047840928.0: 506, 4058519355.0: 507, 4066419546.0: 508, 4067412646.0: 509, 4093205715.0: 510, 4111582846.0: 511, 4116545670.0: 512, 4130591602.0: 513, 4139404259.0: 514, 4154723798.0: 515, 4160280535.0: 516, 4166776076.0: 517, 4172496934.0: 518, 4177809365.0: 519, 4177938046.0: 520, 4197538925.0: 521, 4206251379.0: 522, 4207475045.0: 523, 4209934441.0: 524, 4212963211.0: 525, 4214108647.0: 526, 4222796281.0: 527, 4242181752.0: 528, 4242779283.0: 529, 4269313794.0: 530, 4270026720.0: 531, 4279371998.0: 532, 4281442206.0: 533, 797691271.0: 534, 2233006436.0: 535, 2706976275.0: 536, 659801221.0: 537, 2483893885.0: 538, 718673074.0: 539, 3090027821.0: 540, 85206403.0: 541, 3185256162.0: 542, 80810949.0: 543, 1653106746.0: 544, 272033496.0: 545, 177871942.0: 546, 1261883538.0: 547, 2797376934.0: 548, 3907330866.0: 549, 3822836479.0: 550, 806724226.0: 551, 2564540834.0: 552, 2514612145.0: 553, 2059208720.0: 554, 3515500138.0: 555, 1683451562.0: 556, 2516990097.0: 557, 3296173018.0: 558, 2929779991.0: 559, 459881014.0: 560, 3773180361.0: 561, 3859508378.0: 562, 290351717.0: 563, 3643347096.0: 564, 1135848066.0: 565, 2049252353.0: 566, 2002959678.0: 567, 3110159570.0: 568, 2480932163.0: 569, 1759790561.0: 570, 2786102015.0: 571, 1887103995.0: 572, 1564045362.0: 573, 3119305548.0: 574, 1854759847.0: 575, 694292026.0: 576, 277764587.0: 577, 259290801.0: 578, 1487450971.0: 579, 2801203135.0: 580, 1018409775.0: 581, 301852743.0: 582, 1622242229.0: 583, 2363181071.0: 584, 3124494040.0: 585, 2257216351.0: 586, 122879987.0: 587, 4231632271.0: 588, 2490415.0: 589, 676616208.0: 590, 2769003324.0: 591, 1534312658.0: 592, 2777911965.0: 593, 1301266841.0: 594, 1909587152.0: 595, 351140950.0: 596, 1971343839.0: 597, 2881962883.0: 598, 3780714772.0: 599, 1524452459.0: 600, 4112339551.0: 601, 547641747.0: 602, 1380472149.0: 603, 1047234919.0: 604, 1472689487.0: 605, 1275651656.0: 606, 2848793193.0: 607, 1743908966.0: 608, 1033251067.0: 609, 1664088944.0: 610, 3200427108.0: 611, 267109936.0: 612, 4247002327.0: 613, 2713468314.0: 614, 1256883716.0: 615, 3963881672.0: 616, 187109057.0: 617, 427259328.0: 618, 3901854432.0: 619, 1866741302.0: 620, 705266680.0: 621, 2047469989.0: 622, 2085060165.0: 623, 362229461.0: 624, 3658501279.0: 625, 2905479400.0: 626, 3481926018.0: 627, 3809625092.0: 628, 3317914910.0: 629, 3971981448.0: 630, 736715881.0: 631, 3777760725.0: 632, 2823180219.0: 633, 576460665.0: 634, 562737393.0: 635, 3050781216.0: 636, 3396937852.0: 637, 2886437424.0: 638, 1279461180.0: 639, 980020137.0: 640, 2580872786.0: 641, 1651800883.0: 642, 2699949444.0: 643, 4068573499.0: 644, 680283149.0: 645, 541064000.0: 646, 612939960.0: 647, 1038001265.0: 648, 1740737205.0: 649, 1729538486.0: 650, 1988133253.0: 651, 1363444188.0: 652, 2818720475.0: 653, 583521259.0: 654, 597771734.0: 655, 4198430242.0: 656, 629791662.0: 657, 922369947.0: 658, 3076186543.0: 659, 1764319139.0: 660, 3804852924.0: 661, 31530209.0: 662, 717756578.0: 663, 916032206.0: 664, 4021637519.0: 665, 3580968322.0: 666, 2208058935.0: 667, 1473344451.0: 668, 2976320415.0: 669, 2794657584.0: 670, 490442294.0: 671, 2135109613.0: 672, 3512778844.0: 673, 1757432695.0: 674, 2698148492.0: 675, 4014977891.0: 676, 2177087948.0: 677, 3733907112.0: 678, 1205749392.0: 679, 1859851568.0: 680, 1328395354.0: 681, 1746247192.0: 682, 2367370360.0: 683, 814571494.0: 684, 1786851465.0: 685, 2734603508.0: 686, 3430129558.0: 687, 564368219.0: 688, 1190491527.0: 689, 2609801910.0: 690, 3075435986.0: 691, 3025981879.0: 692, 3177768042.0: 693, 4233694761.0: 694, 2164281863.0: 695, 4208451033.0: 696, 1744894888.0: 697, 2586310361.0: 698, 2886303270.0: 699, 666782168.0: 700, 968076887.0: 701, 1069451950.0: 702, 53273433.0: 703, 2934009333.0: 704, 4011267276.0: 705, 1770306772.0: 706, 506345172.0: 707, 1704561032.0: 708, 282188035.0: 709, 2236883720.0: 710, 2940662614.0: 711, 410460060.0: 712, 4163418029.0: 713, 3305170727.0: 714, 729584122.0: 715, 3965489622.0: 716, 2207758007.0: 717, 3592190641.0: 718, 2178798563.0: 719, 165544973.0: 720, 1043072746.0: 721, 3562458597.0: 722, 3691743791.0: 723, 1880643784.0: 724, 1596573619.0: 725, 3371717812.0: 726, 3795634675.0: 727, 1320518.0: 728, 669035712.0: 729, 1779187190.0: 730, 4071064790.0: 731, 355696872.0: 732, 2462746428.0: 733, 1254829742.0: 734, 3800235333.0: 735, 280611062.0: 736, 2658732226.0: 737, 2267117392.0: 738, 3830036448.0: 739, 2466344911.0: 740, 292149432.0: 741, 3565165550.0: 742, 1283944297.0: 743, 2747048484.0: 744, 3107735134.0: 745, 1135294176.0: 746, 1759134727.0: 747, 3277837614.0: 748, 1022995910.0: 749, 1664928856.0: 750, 1518777715.0: 751, 1659050900.0: 752, 4118563007.0: 753, 2388239786.0: 754, 3056116467.0: 755, 3229001876.0: 756, 1981157257.0: 757, 4112156628.0: 758, 1671199000.0: 759, 200791924.0: 760, 2143323689.0: 761, 1735721311.0: 762, 1931809775.0: 763, 2708079912.0: 764, 3350669824.0: 765, 3362486838.0: 766, 1134080135.0: 767, 766263458.0: 768, 4009257630.0: 769, 930299752.0: 770, 866694338.0: 771, 1291066610.0: 772, 3344479184.0: 773, 3700758979.0: 774, 1494171502.0: 775, 2764269366.0: 776, 726225068.0: 777, 2434701559.0: 778, 2877373754.0: 779, 159874282.0: 780, 2840517227.0: 781, 882498671.0: 782, 1333981237.0: 783, 2799276866.0: 784, 491879765.0: 785, 2438745395.0: 786, 3501551908.0: 787, 2683233668.0: 788, 384603025.0: 789, 3447243659.0: 790, 2770578153.0: 791, 766325301.0: 792, 1284980587.0: 793, 3752983294.0: 794, 1243694752.0: 795, 615194238.0: 796, 2584025107.0: 797, 4010795829.0: 798, 1649401087.0: 799, 2526703612.0: 800, 566208791.0: 801, 2927984591.0: 802, 4002281523.0: 803, 2197523811.0: 804, 1067340610.0: 805, 1928187131.0: 806, 3649854322.0: 807, 2079378085.0: 808, 2745507628.0: 809, 3335623037.0: 810, 1721012636.0: 811, 3714371664.0: 812, 2328477663.0: 813, 1205690224.0: 814, 2662953644.0: 815, 2108825597.0: 816, 4286175417.0: 817, 2137099295.0: 818, 810682345.0: 819, 755077201.0: 820, 4003541172.0: 821, 2931073915.0: 822, 3740971872.0: 823, 959175443.0: 824, 4292799832.0: 825, 289664122.0: 826, 3961465611.0: 827, 2616237000.0: 828, 876221865.0: 829, 1026011570.0: 830, 4121121676.0: 831, 1764056343.0: 832, 2698075604.0: 833, 2226738041.0: 834, 763559135.0: 835, 3838220315.0: 836, 2590217890.0: 837, 2743665656.0: 838, 3999723032.0: 839, 2049541040.0: 840, 1122796086.0: 841, 2929914242.0: 842, 3115727087.0: 843, 770232472.0: 844, 142907214.0: 845, 1128020807.0: 846, 482509469.0: 847, 692642899.0: 848, 1449963323.0: 849, 428646232.0: 850, 389482925.0: 851, 2725752485.0: 852, 1888959064.0: 853, 3370554488.0: 854, 450954405.0: 855, 1571187139.0: 856, 765523553.0: 857, 1711696318.0: 858, 1359262452.0: 859, 3250249737.0: 860, 260448042.0: 861, 2046665559.0: 862, 501262551.0: 863, 2426835297.0: 864, 2949479513.0: 865, 2768458736.0: 866, 2445796005.0: 867, 24348604.0: 868, 1431420043.0: 869, 3576508989.0: 870, 3426714144.0: 871, 3951040901.0: 872, 2868365538.0: 873, 1740566778.0: 874, 3512087869.0: 875, 3867466540.0: 876, 3656712974.0: 877, 4169429378.0: 878, 2040811896.0: 879, 1442381804.0: 880, 1927274783.0: 881, 3299613912.0: 882, 3379256044.0: 883, 385654947.0: 884, 1633278736.0: 885, 2089734597.0: 886, 3521623443.0: 887, 4162317850.0: 888, 408997141.0: 889, 2515916835.0: 890}, {1249151596.0: 0, 1435361449.0: 1}, {693.0: 0, 1601.0: 1, 2620.0: 2, 2623.0: 3, 2624.0: 4, 2625.0: 5, 2626.0: 6, 2627.0: 7, 2629.0: 8, 2631.0: 9, 2641.0: 10, 2647.0: 11, 2648.0: 12, 2650.0: 13, 2651.0: 14, 2653.0: 15, 2659.0: 16, 2661.0: 17, 2662.0: 18, 2663.0: 19, 2665.0: 20, 2666.0: 21, 2667.0: 22, 2668.0: 23, 2669.0: 24, 2671.0: 25, 2672.0: 26, 2678.0: 27, 2683.0: 28, 2685.0: 29, 2687.0: 30, 2689.0: 31, 2690.0: 32, 2691.0: 33, 2695.0: 34, 2699.0: 35, 2700.0: 36, 2908.0: 37, 3460.0: 38, 3474.0: 39, 4133.0: 40, 4134.0: 41, 4135.0: 42, 4136.0: 43, 4137.0: 44, 5727.0: 45, 6563.0: 46, 7267.0: 47, 7534.0: 48, 7540.0: 49, 7545.0: 50, 7546.0: 51, 7552.0: 52, 7553.0: 53, 7598.0: 54, 8471.0: 55, 8475.0: 56, 11767.0: 57, 11769.0: 58, 11771.0: 59, 11774.0: 60, 11813.0: 61, 11967.0: 62, 12233.0: 63, 12460.0: 64, 12749.0: 65, 13049.0: 66, 13213.0: 67, 13214.0: 68, 13502.0: 69, 13507.0: 70, 13509.0: 71, 13567.0: 72, 14312.0: 73, 14973.0: 74, 16966.0: 75, 16988.0: 76, 17421.0: 77, 17453.0: 78, 17463.0: 79, 17464.0: 80, 17465.0: 81, 17466.0: 82, 19928.0: 83, 19943.0: 84, 19947.0: 85, 19950.0: 86, 19952.0: 87, 19972.0: 88, 19988.0: 89, 19996.0: 90, 21440.0: 91, 26360.0: 92, 26707.0: 93, 27042.0: 94, 28134.0: 95, 28206.0: 96, 28220.0: 97, 28228.0: 98, 28403.0: 99, 28425.0: 100, 28551.0: 101, 28665.0: 102, 29011.0: 103, 29103.0: 104, 29104.0: 105, 29106.0: 106, 29750.0: 107, 29751.0: 108, 31027.0: 109, 31028.0: 110, 31418.0: 111, 35273.0: 112, 35281.0: 113, 35851.0: 114, 36568.0: 115, 36864.0: 116, 36865.0: 117, 36866.0: 118, 36928.0: 119, 36947.0: 120, 36963.0: 121, 36973.0: 122, 54636.0: 123, 65303.0: 124, 110152.0: 125, 110413.0: 126, 110465.0: 127, 110813.0: 128, 111240.0: 129, 111320.0: 130, 111361.0: 131, 111369.0: 132, 111426.0: 133, 111428.0: 134, 112050.0: 135, 112053.0: 136, 112058.0: 137, 112059.0: 138, 112379.0: 139, 113043.0: 140, 113051.0: 141, 113055.0: 142, 113501.0: 143, 113505.0: 144, 113509.0: 145, 113510.0: 146, 113514.0: 147, 113760.0: 148, 113767.0: 149, 113781.0: 150, 113784.0: 151, 113787.0: 152, 113789.0: 153, 113792.0: 154, 113794.0: 155, 113798.0: 156, 113800.0: 157, 113803.0: 158, 113806.0: 159, 211536.0: 160, 219533.0: 161, 220845.0: 162, 223596.0: 163, 226593.0: 164, 226875.0: 165, 228414.0: 166, 229236.0: 167, 230080.0: 168, 230136.0: 169, 230433.0: 170, 230434.0: 171, 231945.0: 172, 233866.0: 173, 234604.0: 174, 234686.0: 175, 236853.0: 176, 237565.0: 177, 237668.0: 178, 237736.0: 179, 237789.0: 180, 239853.0: 181, 239854.0: 182, 239856.0: 183, 239865.0: 184, 240929.0: 185, 243880.0: 186, 244252.0: 187, 244361.0: 188, 244367.0: 189, 244373.0: 190, 248698.0: 191, 248706.0: 192, 248723.0: 193, 248727.0: 194, 248731.0: 195, 248733.0: 196, 248738.0: 197, 248740.0: 198, 250644.0: 199, 250646.0: 200, 250647.0: 201, 250649.0: 202, 250651.0: 203, 250652.0: 204, 250653.0: 205, 250655.0: 206, 312991.0: 207, 312992.0: 208, 315037.0: 209, 315082.0: 210, 315086.0: 211, 315089.0: 212, 315090.0: 213, 315094.0: 214, 315096.0: 215, 315098.0: 216, 323951.0: 217, 324669.0: 218, 330877.0: 219, 330909.0: 220, 330919.0: 221, 330923.0: 222, 330931.0: 223, 330935.0: 224, 341826.0: 225, 342826.0: 226, 343095.0: 227, 343275.0: 228, 343276.0: 229, 345763.0: 230, 345764.0: 231, 345765.0: 232, 345769.0: 233, 345770.0: 234, 345773.0: 235, 345779.0: 236, 345780.0: 237, 345783.0: 238, 347054.0: 239, 347060.0: 240, 347064.0: 241, 347067.0: 242, 347068.0: 243, 347069.0: 244, 347071.0: 245, 347074.0: 246, 347077.0: 247, 347081.0: 248, 347082.0: 249, 347083.0: 250, 347087.0: 251, 347088.0: 252, 347468.0: 253, 347470.0: 254, 347742.0: 255, 347743.0: 256, 348123.0: 257, 348124.0: 258, 349201.0: 259, 349204.0: 260, 349205.0: 261, 349207.0: 262, 349208.0: 263, 349212.0: 264, 349215.0: 265, 349217.0: 266, 349221.0: 267, 349223.0: 268, 349224.0: 269, 349227.0: 270, 349228.0: 271, 349231.0: 272, 349233.0: 273, 349234.0: 274, 349236.0: 275, 349237.0: 276, 349239.0: 277, 349242.0: 278, 349243.0: 279, 349245.0: 280, 349248.0: 281, 349249.0: 282, 349251.0: 283, 349252.0: 284, 349254.0: 285, 349256.0: 286, 349257.0: 287, 349909.0: 288, 349910.0: 289, 350025.0: 290, 350026.0: 291, 350034.0: 292, 350035.0: 293, 350036.0: 294, 350047.0: 295, 350048.0: 296, 350050.0: 297, 350052.0: 298, 350060.0: 299, 350404.0: 300, 350406.0: 301, 350417.0: 302, 358585.0: 303, 362316.0: 304, 363291.0: 305, 364498.0: 306, 364511.0: 307, 364512.0: 308, 364516.0: 309, 364846.0: 310, 364849.0: 311, 364851.0: 312, 365226.0: 313, 367226.0: 314, 367229.0: 315, 367230.0: 316, 367231.0: 317, 368323.0: 318, 368703.0: 319, 370129.0: 320, 370365.0: 321, 370369.0: 322, 370370.0: 323, 370371.0: 324, 370372.0: 325, 370376.0: 326, 370377.0: 327, 371110.0: 328, 374746.0: 329, 374887.0: 330, 376566.0: 331, 382649.0: 332, 382652.0: 333, 392091.0: 334, 392092.0: 335, 392096.0: 336, 3101264.0: 337, 3101265.0: 338, 3101276.0: 339, 3101277.0: 340, 3101278.0: 341, 3101281.0: 342, 3101295.0: 343, 3101298.0: 344, 76777977.0: 345, 140508824.0: 346, 155025754.0: 347, 161116554.0: 348, 166144051.0: 349, 184130260.0: 350, 265596470.0: 351, 290968133.0: 352, 324219018.0: 353, 326145279.0: 354, 343675607.0: 355, 375596892.0: 356, 417439342.0: 357, 427190305.0: 358, 451247265.0: 359, 459622912.0: 360, 474937058.0: 361, 495499448.0: 362, 517393445.0: 363, 521193205.0: 364, 537058436.0: 365, 539736263.0: 366, 556207774.0: 367, 573361098.0: 368, 578268689.0: 369, 661592221.0: 370, 776370318.0: 371, 805009159.0: 372, 831457738.0: 373, 913457246.0: 374, 945486485.0: 375, 953911282.0: 376, 1024935327.0: 377, 1036475434.0: 378, 1194733749.0: 379, 1196370261.0: 380, 1310645587.0: 381, 1339864932.0: 382, 1444953608.0: 383, 1460005906.0: 384, 1497450520.0: 385, 1513195675.0: 386, 1669014081.0: 387, 1683226652.0: 388, 1689199847.0: 389, 1716576979.0: 390, 1720607818.0: 391, 1782825888.0: 392, 1843547191.0: 393, 1877389048.0: 394, 1901813274.0: 395, 1923795190.0: 396, 1939126639.0: 397, 1995225082.0: 398, 2071433066.0: 399, 2128415201.0: 400, 2179956254.0: 401, 2236065624.0: 402, 2247020454.0: 403, 2266223038.0: 404, 2287895551.0: 405, 2301203405.0: 406, 2314553085.0: 407, 2383496428.0: 408, 2411710238.0: 409, 2550824685.0: 410, 2553274278.0: 411, 2644170819.0: 412, 2666080958.0: 413, 2711656918.0: 414, 2766067434.0: 415, 2799830701.0: 416, 2903624228.0: 417, 2929226755.0: 418, 2966369767.0: 419, 3062339720.0: 420, 3090046756.0: 421, 3116002924.0: 422, 3235329434.0: 423, 3244757043.0: 424, 3266458466.0: 425, 3281577038.0: 426, 3340248101.0: 427, 3380228305.0: 428, 3381051804.0: 429, 3388888457.0: 430, 3413062402.0: 431, 3458587115.0: 432, 3488398301.0: 433, 3490264620.0: 434, 3518505671.0: 435, 3630521121.0: 436, 3735629129.0: 437, 3752194971.0: 438, 3808984457.0: 439, 3825501859.0: 440, 3860255648.0: 441, 3884013890.0: 442, 3924695592.0: 443, 3926100622.0: 444, 3955671087.0: 445, 3999479884.0: 446, 4004161078.0: 447, 4010626683.0: 448, 4024821312.0: 449, 4027900200.0: 450, 4042421561.0: 451, 4062380886.0: 452, 4085701012.0: 453, 4142419592.0: 454, 4162195315.0: 455, 4201804795.0: 456, 4224301822.0: 457, 4264164619.0: 458, 4275005722.0: 459, 4292064498.0: 460, 36209.0: 461, 28213.0: 462, 364848.0: 463, 2686.0: 464, 9234.0: 465, 3764266095.0: 466, 315093.0: 467, 113776.0: 468, 24160.0: 469, 367228.0: 470, 65304.0: 471, 364850.0: 472, 113786.0: 473, 1787791406.0: 474, 2441110378.0: 475, 113796.0: 476, 345778.0: 477, 2326156761.0: 478, 373450.0: 479, 34218.0: 480, 234360.0: 481, 3411.0: 482, 17474.0: 483, 349203.0: 484, 315084.0: 485, 347073.0: 486, 113056.0: 487, 323592.0: 488, 2003.0: 489, 347464.0: 490, 695.0: 491, 349240.0: 492, 371362.0: 493, 345777.0: 494, 349214.0: 495, 165296503.0: 496, 2393218453.0: 497, 28424.0: 498, 113050.0: 499, 343120.0: 500, 347063.0: 501, 569688203.0: 502, 28664.0: 503, 2117775820.0: 504, 113059.0: 505, 335097.0: 506, 428932144.0: 507, 231919.0: 508, 1204664076.0: 509, 234818.0: 510, 11755.0: 511, 237671.0: 512, 315151.0: 513, 349209.0: 514, 220367.0: 515, 350043.0: 516, 370373.0: 517, 349216.0: 518, 745884362.0: 519, 2072310710.0: 520, 386525.0: 521, 2565002966.0: 522, 347078.0: 523, 29108.0: 524, 349247.0: 525, 11752.0: 526, 19877.0: 527, 2223.0: 528, 237442.0: 529, 3894903607.0: 530, 330958.0: 531, 113572.0: 532, 248747.0: 533, 4096752855.0: 534, 312993.0: 535, 2680.0: 536, 520149647.0: 537, 397200431.0: 538, 363294.0: 539, 250648.0: 540, 349210.0: 541, 243847.0: 542, 13568.0: 543, 350029.0: 544, 3615059432.0: 545, 239855.0: 546, 4239475757.0: 547, 4113388503.0: 548, 347080.0: 549, 113773.0: 550, 345781.0: 551, 364499.0: 552, 2481551162.0: 553, 4157391951.0: 554, 2573469914.0: 555, 347061.0: 556, 315088.0: 557, 330979.0: 558, 370375.0: 559, 113028.0: 560, 367232.0: 561, 349206.0: 562, 345364.0: 563, 1659195903.0: 564, 111427.0: 565, 236171.0: 566, 244270.0: 567, 33638.0: 568, 11668.0: 569, 2340820763.0: 570, 244310.0: 571, 1846008657.0: 572, 3101296.0: 573, 363592.0: 574, 11753.0: 575, 364506.0: 576, 2664.0: 577, 384461.0: 578, 236852.0: 579, 11751.0: 580, 3958177390.0: 581, 349222.0: 582, 113804.0: 583, 2649.0: 584, 2693.0: 585, 2376368940.0: 586, 364500.0: 587, 36967.0: 588, 336439.0: 589, 345774.0: 590, 2567056182.0: 591, 65306.0: 592, 315153.0: 593, 3101267.0: 594, 383121.0: 595, 3104542014.0: 596, 335677.0: 597, 345767.0: 598, 113783.0: 599, 2677.0: 600, 394140.0: 601, 218629.0: 602, 112277.0: 603, 349218.0: 604, 152993313.0: 605, 27267.0: 606, 233639.0: 607, 400773925.0: 608, 113503.0: 609, 349241.0: 610, 348121.0: 611, 113788.0: 612, 2674.0: 613, 113807.0: 614, 11765.0: 615, 3208878909.0: 616, 14313.0: 617, 347085.0: 618, 27849.0: 619, 4006252765.0: 620, 3497674992.0: 621, 349246.0: 622, 4579.0: 623, 374910.0: 624, 315097.0: 625, 372622.0: 626, 347062.0: 627, 1799997044.0: 628, 365222.0: 629, 2466494005.0: 630, 14311.0: 631, 29105.0: 632, 2628.0: 633, 1791472115.0: 634, 112052.0: 635, 2098059033.0: 636, 244278.0: 637, 347466.0: 638, 330932.0: 639, 110564.0: 640, 2697.0: 641, 349219.0: 642, 1524834916.0: 643, 347076.0: 644, 349253.0: 645, 367655.0: 646, 349225.0: 647, 1349003275.0: 648, 350042.0: 649, 2264899535.0: 650, 2926.0: 651, 330959.0: 652, 371060.0: 653, 382651.0: 654, 349912.0: 655, 2694.0: 656, 1242592521.0: 657, 376564.0: 658, 35852.0: 659, 3830916057.0: 660, 237798.0: 661, 349244.0: 662, 3378608561.0: 663, 349213.0: 664, 3770260546.0: 665, 355669911.0: 666, 4138.0: 667, 17764.0: 668, 824149063.0: 669, 244358.0: 670, 350407.0: 671, 387454294.0: 672, 347089.0: 673, 250643.0: 674, 330980.0: 675, 3475599282.0: 676, 4284068713.0: 677, 350046.0: 678, 334912.0: 679, 345572.0: 680}, {0.0: 0, 52685841.0: 1, 64262561.0: 2, 146240166.0: 3, 205131284.0: 4, 236510344.0: 5, 328110459.0: 6, 344567039.0: 7, 350442850.0: 8, 352784134.0: 9, 406601631.0: 10, 443944295.0: 11, 449814752.0: 12, 509930497.0: 13, 525466502.0: 14, 573614902.0: 15, 576825214.0: 16, 583005055.0: 17, 634533734.0: 18, 650104445.0: 19, 672055250.0: 20, 746832736.0: 21, 749073203.0: 22, 780607919.0: 23, 791522300.0: 24, 828071588.0: 25, 852690539.0: 26, 878352406.0: 27, 880584773.0: 28, 899215905.0: 29, 915355450.0: 30, 1019807271.0: 31, 1099433900.0: 32, 1132173523.0: 33, 1171535613.0: 34, 1212042119.0: 35, 1271805617.0: 36, 1300635826.0: 37, 1302335713.0: 38, 1379057629.0: 39, 1434012567.0: 40, 1514576321.0: 41, 1557071804.0: 42, 1592644896.0: 43, 1596964631.0: 44, 1644183440.0: 45, 1699466202.0: 46, 1722512241.0: 47, 1752234819.0: 48, 1777389026.0: 49, 1828554737.0: 50, 1855785467.0: 51, 1951568171.0: 52, 2275065867.0: 53, 2328432886.0: 54, 2383068275.0: 55, 2553768918.0: 56, 2583969418.0: 57, 2601207467.0: 58, 2645558274.0: 59, 2712310530.0: 60, 2720189389.0: 61, 2742024627.0: 62, 2743615902.0: 63, 2746444292.0: 64, 2766505351.0: 65, 2780845981.0: 66, 2853715430.0: 67, 2899574541.0: 68, 2944820864.0: 69, 2971786811.0: 70, 2997160533.0: 71, 2999019152.0: 72, 3003321511.0: 73, 3049836108.0: 74, 3058066393.0: 75, 3098649155.0: 76, 3144218308.0: 77, 3187964512.0: 78, 3218892378.0: 79, 3230220419.0: 80, 3236768838.0: 81, 3266023967.0: 82, 3278501928.0: 83, 3288611889.0: 84, 3327004361.0: 85, 3434189395.0: 86, 3536283403.0: 87, 3584729874.0: 88, 3703114626.0: 89, 3756823055.0: 90, 3839168801.0: 91, 3847858977.0: 92, 3883628989.0: 93, 3953242029.0: 94, 4047937050.0: 95, 4130496179.0: 96, 4159714436.0: 97, 4160194878.0: 98, 4253085783.0: 99, 4261980312.0: 100, 4288815819.0: 101, 1130211456.0: 102, 1610931551.0: 103, 1381654457.0: 104, 3576036187.0: 105, 1941857582.0: 106, 1207362657.0: 107, 390181215.0: 108, 3980996196.0: 109, 3172535531.0: 110, 1345740050.0: 111, 2851636557.0: 112, 2331549845.0: 113, 2281614542.0: 114, 2336598774.0: 115, 1227713619.0: 116, 1771348263.0: 117, 4178414821.0: 118, 657550724.0: 119, 1516284306.0: 120, 158668945.0: 121, 1539747680.0: 122, 1841860726.0: 123, 294286260.0: 124, 1417325022.0: 125, 705322269.0: 126, 3692883769.0: 127, 4232223328.0: 128, 1463809486.0: 129, 1121820193.0: 130, 1836137969.0: 131, 3990548621.0: 132, 732716015.0: 133, 1389692912.0: 134, 4072316652.0: 135, 1728182562.0: 136, 234382371.0: 137, 1011244654.0: 138, 1662195780.0: 139, 994277907.0: 140, 300655516.0: 141, 1438172137.0: 142, 469415783.0: 143, 1773310324.0: 144, 268880308.0: 145, 1169185336.0: 146, 1832906182.0: 147}, {543223747.0: 0, 1037565863.0: 1, 3463352047.0: 2, 0.0: 3}]
list_of_cols_to_normalize = [2, 3, 7, 9, 10]

transform_true = False

def column_norm(column,mappings):
    listy = []
    for i,val in enumerate(column.reshape(-1)):
        if not (val in mappings):
            mappings[val] = int(max(mappings.values())) + 1
        listy.append(mappings[val])
    return np.array(listy)

def Normalize(data_arr):
    if list_of_cols_to_normalize:
        for i,mapping in zip(list_of_cols_to_normalize, mappings):
            if i >= data_arr.shape[1]:
                break
            col = data_arr[:, i]
            normcol = column_norm(col,mapping)
            data_arr[:, i] = normcol
        return data_arr
    else:
        return data_arr

def transform(X):
    mean = None
    components = None
    whiten = None
    explained_variance = None
    if (transform_true):
        mean = np.array([])
        components = np.array([])
        whiten = None
        explained_variance = np.array([])
        X = X - mean

    X_transformed = np.dot(X, components.T)
    if whiten:
        X_transformed /= np.sqrt(explained_variance)
    return X_transformed

# Preprocessor for CSV files

ignorelabels=[]
ignorecolumns=[]
target="Survived"
important_idxs=[0,1,2,3,4,5,6,7,8,9,10]

def preprocess(inputcsvfile, outputcsvfile, headerless=False, testfile=False, target='', ignorecolumns=[], ignorelabels=[], trim=False):
    #This function streams in a csv and outputs a csv with the correct columns and target column on the right hand side. 
    #Precursor to clean

    il=[]

    ignorelabels=[]
    ignorecolumns=[]
    target="Survived"
    important_idxs=[0,1,2,3,4,5,6,7,8,9,10]
    if ignorelabels == [] and ignorecolumns == [] and target == "":
        return -1
    if not trim:
        ignorecolumns = []
    if (testfile):
        target = ''
        hc = -1 
    with open(outputcsvfile, "w+") as outputfile:
        with open(inputcsvfile) as csvfile:
            reader = csv.reader(csvfile)
            if (headerless == False):
                header=next(reader, None)
                try:
                    if not testfile:
                        if (target != ''): 
                            hc = header.index(target)
                        else:
                            hc = len(header) - 1
                            target=header[hc]
                except:
                    raise NameError("Target '" + target + "' not found! Header must be same as in file passed to btc.")
                for i in range(0, len(ignorecolumns)):
                    try:
                        col = header.index(ignorecolumns[i])
                        if not testfile:
                            if (col == hc):
                                raise ValueError("Attribute '" + ignorecolumns[i] + "' is the target. Header must be same as in file passed to btc.")
                        il = il + [col]
                    except ValueError:
                        raise
                    except:
                        raise NameError("Attribute '" + ignorecolumns[i] + "' not found in header. Header must be same as in file passed to btc.")
                first = True
                for i in range(0, len(header)):

                    if (i == hc):
                        continue
                    if (i in il):
                        continue
                    if first:
                        first = False
                    else:
                        print(",", end='', file=outputfile)
                    print(header[i], end='', file=outputfile)
                if not testfile:
                    print("," + header[hc], file=outputfile)
                else:
                    print("", file=outputfile)

                for row in csv.DictReader(open(inputcsvfile)):
                    if target and (row[target] in ignorelabels):
                        continue
                    first = True
                    for name in header:
                        if (name in ignorecolumns):
                            continue
                        if (name == target):
                            continue
                        if first:
                            first = False
                        else:
                            print(",", end='', file=outputfile)
                        if (',' in row[name]):
                            print('"' + row[name].replace('"', '') + '"', end='', file=outputfile)
                        else:
                            print(row[name].replace('"', ''), end='', file=outputfile)
                    if not testfile:
                        print("," + row[target], file=outputfile)
                    else:
                        if len(important_idxs) == 1:
                            print(",", file=outputfile)
                        else:
                            print("", file=outputfile)

            else:
                try:
                    if (target != ""): 
                        hc = int(target)
                    else:
                        hc = -1
                except:
                    raise NameError("No header found but attribute name given as target. Header must be same as in file passed to btc.")
                for i in range(0, len(ignorecolumns)):
                    try:
                        col = int(ignorecolumns[i])
                        if (col == hc):
                            raise ValueError("Attribute " + str(col) + " is the target. Cannot ignore. Header must be same as in file passed to btc.")
                        il = il + [col]
                    except ValueError:
                        raise
                    except:
                        raise ValueError("No header found but attribute name given in ignore column list. Header must be same as in file passed to btc.")
                for row in reader:
                    first = True
                    if (hc == -1) and (not testfile):
                        hc = len(row) - 1
                    if (row[hc] in ignorelabels):
                        continue
                    for i in range(0, len(row)):
                        if (i in il):
                            continue
                        if (i == hc):
                            continue
                        if first:
                            first = False
                        else:
                            print(",", end='', file=outputfile)
                        if (',' in row[i]):
                            print('"' + row[i].replace('"', '') + '"', end='', file=outputfile)
                        else:
                            print(row[i].replace('"', ''), end = '', file=outputfile)
                    if not testfile:
                        print("," + row[hc], file=outputfile)
                    else:
                        if len(important_idxs) == 1:
                            print(",", file=outputfile)
                        else:
                            print("", file=outputfile)


def clean(filename, outfile, rounding=-1, headerless=False, testfile=False, trim=False):
    #This function takes a preprocessed csv and cleans it to real numbers for prediction or validation


    clean.classlist = []
    clean.testfile = testfile
    clean.mapping = {}
    

    def convert(cell):
        value = str(cell)
        try:
            result = int(value)
            return result
        except:
            try:
                result=float(value)
                if math.isnan(result):
                    #if nan parse to string
                    raise ValueError('')
                if (rounding != -1):
                    result = int(result * math.pow(10, rounding)) / math.pow(10, rounding)
                return result
            except:
                result = (binascii.crc32(value.encode('utf8')) % (1 << 32))
                return result

    #Function to return key for any value 
    def get_key(val, clean_classmapping):
        if clean_classmapping == {}:
            return val
        for key, value in clean_classmapping.items(): 
            if val == value:
                return key
        if val not in list(clean_classmapping.values):
            raise ValueError("Label key does not exist")


    #Function to convert the class label
    def convertclassid(cell):
        if (clean.testfile):
            return convert(cell)
        value = str(cell)
        if (value == ''):
            raise ValueError("All cells in the target column must contain a class label.")

        if (not clean.mapping == {}):
            result = -1
            try:
                result = clean.mapping[cell]
            except:
                raise ValueError("Class label '" + value + "' encountered in input not defined in user-provided mapping.")
            if (not result == int(result)):
                raise ValueError("Class labels must be mapped to integer.")
            if (not str(result) in clean.classlist):
                clean.classlist = clean.classlist + [str(result)]
            return result
        try:
            result = float(cell)
            if (rounding != -1):
                result = int(result * math.pow(10, rounding)) / math.pow(10, rounding)
            else:
                result = int(int(result * 100) / 100)  # round classes to two digits

            if (not str(result) in clean.classlist):
                clean.classlist = clean.classlist + [str(result)]
        except:
            result = (binascii.crc32(value.encode('utf8')) % (1 << 32))
            if (result in clean.classlist):
                result = clean.classlist.index(result)
            else:
                clean.classlist = clean.classlist + [result]
                result = clean.classlist.index(result)
            if (not result == int(result)):
                raise ValueError("Class labels must be mappable to integer.")
        finally:
            if (result < 0):
                raise ValueError("Integer class labels must be positive and contiguous.")

        return result


    #Main Cleaning Code
    rowcount = 0
    with open(filename) as csv_file:
        reader = csv.reader(csv_file)
        f = open(outfile, "w+")
        if (headerless == False):
            next(reader, None)
        outbuf = []
        for row in reader:
            if (row == []):  # Skip empty rows
                continue
            rowcount = rowcount + 1
            if not transform_true:
                rowlen = num_attr if trim else num_attr + len(ignorecolumns)
            else:
                rowlen = num_attr_before_transform if trim else num_attr_before_transform + len(ignorecolumns)
            if (not testfile):
                rowlen = rowlen + 1    
            if ((len(row) - (1 if ((testfile and len(important_idxs) == 1)) else 0))  != rowlen) and not (row == ['','']):
                raise ValueError("Column count must match trained predictor. Row " + str(rowcount) + " differs. Expected Row length: " + str(rowlen) + ", Actual Row Length: " + str(len(row)))
            i = 0
            for elem in row:
                if(i + 1 < len(row)):
                    outbuf.append(str(convert(elem)))
                    outbuf.append(',')
                else:
                    classid = str(convertclassid(elem))
                    outbuf.append(classid)
                i = i + 1
            if (len(outbuf) < IOBUF):
                outbuf.append(os.linesep)
            else:
                print(''.join(outbuf), file=f)
                outbuf = []
        print(''.join(outbuf), end="", file=f)
        f.close()

        if (testfile == False and not len(clean.classlist) >= 2):
            raise ValueError("Number of classes must be at least 2.")

        return get_key, clean.mapping


# Helper (save an import)
def argmax(l):
    f = lambda i: l[i]
    return max(range(len(l)), key=f)
# Classifier

def single_classify(row, return_probabilities=False):
    #inits
    x = row
    o = [0] * num_output_logits


    #Nueron Equations
    h_0 = max((((-0.33339837 * float(x[0]))+ (-0.5606151 * float(x[1]))+ (-0.9529817 * float(x[2]))+ (-0.2631269 * float(x[3]))+ (0.18217707 * float(x[4]))+ (-0.013460398 * float(x[5]))+ (0.5386623 * float(x[6]))+ (-0.24647808 * float(x[7]))+ (0.10353424 * float(x[8]))+ (-0.27714983 * float(x[9]))+ (-0.13353992 * float(x[10]))) + -0.006552353), 0)
    h_1 = max((((60.698563 * float(x[0]))+ (-3.0376277 * float(x[1]))+ (130.87866 * float(x[2]))+ (-2.9745166 * float(x[3]))+ (-3.3303926 * float(x[4]))+ (-3.9486704 * float(x[5]))+ (-3.9859526 * float(x[6]))+ (92.38113 * float(x[7]))+ (0.16111621 * float(x[8]))+ (-4.8051887 * float(x[9]))+ (-3.657038 * float(x[10]))) + -4.3919363), 0)
    o[0] = (0.12959528 * h_0)+ (-0.00017374723 * h_1) + -0.79909694



    #Output Decision Rule
    if num_output_logits==1:
        if return_probabilities:
            exp_o = 1./(1. + np.exp(-o[0]))
            return np.array([exp_o, 1.-exp_o])
        else:
            return o[0]>=0
    else:
        if return_probabilities:
            exps = np.exp(o)
            Z = sum(exps).reshape(-1, 1)
            return exps/Z
        else:
            return argmax(o)


def classify(arr, transform_true=False, return_probabilities=False):
    #apply transformation if necessary
    if transform_true:
        trans = transform(arr[:, :-1])
        arr = np.concatenate((trans, cleanarr[:, -1].reshape(-1, 1)), axis = 1)
    #init
    w_h = np.array([[-0.33339837193489075, -0.5606151223182678, -0.95298171043396, -0.2631269097328186, 0.18217706680297852, -0.013460397720336914, 0.538662314414978, -0.24647808074951172, 0.10353423655033112, -0.27714982628822327, -0.13353991508483887], [60.69856262207031, -3.037627696990967, 130.878662109375, -2.9745166301727295, -3.330392599105835, -3.9486703872680664, -3.985952615737915, 92.3811264038086, 0.16111621260643005, -4.8051886558532715, -3.6570379734039307]])
    b_h = np.array([-0.006552353035658598, -4.391936302185059])
    w_o = np.array([[0.12959527969360352, -0.00017374723393004388]])
    b_o = np.array(-0.799096941947937)

    #Hidden Layer
    h = np.dot(arr, w_h.T) + b_h
    
    relu = np.maximum(h, np.zeros_like(h))


    #Output
    out = np.dot(relu, w_o.T) + b_o
    if return_probabilities:
        return np.array(np.exp(out)) / np.sum(np.exp(out), axis=1).reshape(-1,1)
    if num_output_logits == 1:
        if return_probabilities:
            exp_o = 1./(1. + np.exp(-out))
            return np.concatenate((exp_o, 1.-exp_o), axis=1)
        else:
            return (out >= 0).astype('int').reshape(-1)
    else:
        if return_probabilities:
            exps = np.exp(out)
            Z = sum(exps, axis=1).reshape(-1, 1)
            return exps/Z
        else:
            return (np.argmax(out, axis=1)).reshape(-1)



def Predict(arr,headerless,csvfile, get_key, classmapping):
    with open(csvfile, 'r') as csvinput:
        #readers and writers
        reader = csv.reader(csvinput)

        #print original header
        if (not headerless):
            print(','.join(next(reader, None) + ["Prediction"]))
        
        outputs = classify(arr)
        for i, row in enumerate(reader):
            #use the transformed array as input to predictor
            pred = str(get_key(int(outputs[i]), classmapping))
            #use original untransformed line to write out
            row.append(pred)
            print(','.join(['"' + field + '"' if ',' in field else field for field in row]))


def Validate(cleanarr):
    if n_classes == 2:
        #note that classification is a single line of code
        outputs = classify(cleanarr[:, :-1])


        #metrics
        count, correct_count, num_TP, num_TN, num_FP, num_FN, num_class_1, num_class_0 = 0, 0, 0, 0, 0, 0, 0, 0
        correct_count = int(np.sum(outputs.reshape(-1) == cleanarr[:, -1].reshape(-1)))
        count = outputs.shape[0]
        num_TP = int(np.sum(np.logical_and(outputs.reshape(-1) == 1, cleanarr[:, -1].reshape(-1) == 1)))
        num_TN = int(np.sum(np.logical_and(outputs.reshape(-1) == 0, cleanarr[:, -1].reshape(-1) == 0)))
        num_FN = int(np.sum(np.logical_and(outputs.reshape(-1) == 0, cleanarr[:, -1].reshape(-1) == 1)))
        num_FP = int(np.sum(np.logical_and(outputs.reshape(-1) == 1, cleanarr[:, -1].reshape(-1) == 0)))
        num_class_0 = int(np.sum(cleanarr[:, -1].reshape(-1) == 0))
        num_class_1 = int(np.sum(cleanarr[:, -1].reshape(-1) == 1))
        return count, correct_count, num_TP, num_TN, num_FP, num_FN, num_class_1, num_class_0, outputs


    else:
        #validation
        outputs = classify(cleanarr[:, :-1])


        #metrics
        count, correct_count = 0, 0
        numeachclass = {}
        for k, o in enumerate(outputs):
            if int(o) == int(float(cleanarr[k, -1])):
                correct_count += 1
            if int(float(cleanarr[k, -1])) in numeachclass.keys():
                numeachclass[int(float(cleanarr[k, -1]))] += 1
            else:
                numeachclass[int(float(cleanarr[k, -1]))] = 1
            count += 1
        return count, correct_count, numeachclass, outputs
    


# Main method
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Predictor trained on '+TRAINFILE)
    parser.add_argument('csvfile', type=str, help='CSV file containing test set (unlabeled).')
    parser.add_argument('-validate', action='store_true', help='Validation mode. csvfile must be labeled. Output is classification statistics rather than predictions.')
    parser.add_argument('-cleanfile',action='store_true',help='Use this flag to save prediction time if the csvfile you are passing has already been preprocessed. Implies headerless.')
    parser.add_argument('-headerless', help='Do not treat the first line of csvfile as a header.', action='store_true')
    parser.add_argument('-json', action="store_true", default=False, help="report measurements as json")
    parser.add_argument('-trim', action="store_true", help="If true, the prediction will not output ignored columns.")
    args = parser.parse_args()
    faulthandler.enable()

    if args.validate:
        args.trim = True


    #clean if not already clean
    if not args.cleanfile:
        cleanfile = tempfile.NamedTemporaryFile().name
        preprocessedfile = tempfile.NamedTemporaryFile().name
        output = preprocess(args.csvfile,preprocessedfile,args.headerless,(not args.validate), trim=args.trim)
        get_key, classmapping = clean(preprocessedfile if output!=-1 else args.csvfile, cleanfile, -1, args.headerless, (not args.validate), trim=args.trim)
    else:
        cleanfile=args.csvfile
        preprocessedfile=args.csvfile
        get_key = lambda x, y: x
        classmapping = {}
        output = None


    #load file
    cleanarr = np.loadtxt(cleanfile, delimiter=',', dtype='float64')
    if not args.trim and ignorecolumns != []:
        cleanarr = cleanarr[:, important_idxs]


    #Normalize
    cleanarr = Normalize(cleanarr)


    #Transform
    if transform_true:
        if args.validate:
            trans = transform(cleanarr[:, :-1])
            cleanarr = np.concatenate((trans, cleanarr[:, -1].reshape(-1, 1)), axis = 1)
        else:
            cleanarr = transform(cleanarr)


    #Predict
    if not args.validate:
        Predict(cleanarr, args.headerless, preprocessedfile if output!=-1 else args.csvfile, get_key, classmapping)


    #Validate
    else:
        classifier_type = 'NN'
        if n_classes == 2:
            count, correct_count, num_TP, num_TN, num_FP, num_FN, num_class_1, num_class_0, preds = Validate(cleanarr)
        else:
            count, correct_count, numeachclass, preds = Validate(cleanarr)
        #Correct Labels
        true_labels = cleanarr[:, -1]


        #Report Metrics
        model_cap = 27
        if args.json:
            import json
        if n_classes == 2:
            #Base metrics
            FN = float(num_FN) * 100.0 / float(count)
            FP = float(num_FP) * 100.0 / float(count)
            TN = float(num_TN) * 100.0 / float(count)
            TP = float(num_TP) * 100.0 / float(count)
            num_correct = correct_count

            #Calculated Metrics
            if int(num_TP + num_FN) != 0:
                TPR = num_TP / (num_TP + num_FN) # Sensitivity, Recall
            if int(num_TN + num_FP) != 0:
                TNR = num_TN / (num_TN + num_FP) # Specificity
            if int(num_TP + num_FP) != 0:
                PPV = num_TP / (num_TP + num_FP) # Recall
            if int(num_FN + num_TP) != 0:
                FNR = num_FN / (num_FN + num_TP) # Miss rate
            if int(2 * num_TP + num_FP + num_FN) != 0:
                FONE = 2 * num_TP / (2 * num_TP + num_FP + num_FN) # F1 Score
            if int(num_TP + num_FN + num_FP) != 0:
                TS = num_TP / (num_TP + num_FN + num_FP) # Critical Success Index
            #Best Guess Accuracy
            randguess = int(float(10000.0 * max(num_class_1, num_class_0)) / count) / 100.0
            #Model Accuracy
            classbalance = [float(num_class_0)/count, float(num_class_1)/count]
            H = float(-1.0 * sum([classbalance[i] * math.log(classbalance[i]) / math.log(2) for i in range(len(classbalance))]))

            modelacc = int(float(num_correct * 10000) / count) / 100.0
            #Report
            json_dict = {'instance_count':                        count ,
                         'classifier_type':                        classifier_type,
                         'classes':                            2 ,
                         'false_negative_instances':    num_FN ,
                         'false_positive_instances':    num_FP ,
                         'true_positive_instances':    num_TP ,
                         'true_negative_instances':    num_TN,
                         'false_negatives':                        FN ,
                         'false_positives':                        FP ,
                         'true_negatives':                        TN ,
                         'true_positives':                        TP ,
                         'number_correct':                        num_correct ,
                         'accuracy': {
                             'best_guess': randguess,
                             'improvement': modelacc-randguess,
                             'model_accuracy': modelacc,
                         },
                         'model_capacity':                        model_cap ,
                         'generalization_ratio':                int(float(num_correct * 100) / model_cap) * H/ 100.0,
                         'model_efficiency':                    int(100 * (modelacc - randguess) / model_cap) / 100.0,
                        'shannon_entropy_of_labels':           H,
                        'classbalance':                        classbalance}
            if args.json:
                pass
            else:
                if classifier_type == 'NN':
                    print("Classifier Type:                    Neural Network")
                else:
                    print("Classifier Type:                    Decision Tree")
                print("System Type:                        Binary classifier")
                print("Best-guess accuracy:                {:.2f}%".format(randguess))
                print("Model accuracy:                     {:.2f}%".format(modelacc) + " (" + str(int(num_correct)) + "/" + str(count) + " correct)")
                print("Improvement over best guess:        {:.2f}%".format(modelacc - randguess) + " (of possible " + str(round(100 - randguess, 2)) + "%)")
                print("Model capacity (MEC):               {:.0f} bits".format(model_cap))
                print("Generalization ratio:               {:.2f}".format(int(float(num_correct * 100) / model_cap) / 100.0 * H) + " bits/bit")
                print("Model efficiency:                   {:.2f}%/parameter".format(int(100 * (modelacc - randguess) / model_cap) / 100.0))
                print("System behavior")
                print("True Negatives:                     {:.2f}%".format(TN) + " (" + str(int(num_TN)) + "/" + str(count) + ")")
                print("True Positives:                     {:.2f}%".format(TP) + " (" + str(int(num_TP)) + "/" + str(count) + ")")
                print("False Negatives:                    {:.2f}%".format(FN) + " (" + str(int(num_FN)) + "/" + str(count) + ")")
                print("False Positives:                    {:.2f}%".format(FP) + " (" + str(int(num_FP)) + "/" + str(count) + ")")
                if int(num_TP + num_FN) != 0:
                    print("True Pos. Rate/Sensitivity/Recall:  {:.2f}".format(TPR))
                if int(num_TN + num_FP) != 0:
                    print("True Neg. Rate/Specificity:         {:.2f}".format(TNR))
                if int(num_TP + num_FP) != 0:
                    print("Precision:                          {:.2f}".format(PPV))
                if int(2 * num_TP + num_FP + num_FN) != 0:
                    print("F-1 Measure:                        {:.2f}".format(FONE))
                if int(num_TP + num_FN) != 0:
                    print("False Negative Rate/Miss Rate:      {:.2f}".format(FNR))
                if int(num_TP + num_FN + num_FP) != 0:
                    print("Critical Success Index:             {:.2f}".format(TS))
        #Multiclass
        else:
            num_correct = correct_count
            modelacc = int(float(num_correct * 10000) / count) / 100.0
            randguess = round(max(numeachclass.values()) / sum(numeachclass.values()) * 100, 2)
            classbalance = [float(numofcertainclass) / count for numofcertainclass in numeachclass.values()]
            H = float(-1.0 * sum([classbalance[i] * math.log(classbalance[i]) / math.log(2) for i in range(len(classbalance))]))

            if args.json:
                json_dict = {'instance_count':                        count,
                            'classifier_type':                        classifier_type,
                            'classes':                            n_classes,
                             'number_correct': num_correct,
                             'accuracy': {
                                 'best_guess': randguess,
                                 'improvement': modelacc - randguess,
                                 'model_accuracy': modelacc,
                             },
                             'model_capacity': model_cap,
                            'generalization_ratio':                int(float(num_correct * 100) / model_cap) / 100.0 * H,
                            'model_efficiency':                    int(100 * (modelacc - randguess) / model_cap) / 100.0,
                        'shannon_entropy_of_labels':           H,
                        'classbalance':                        classbalance}
            else:
                if classifier_type == 'NN':
                    print("Classifier Type:                    Neural Network")
                else:
                    print("Classifier Type:                    Decision Tree")
                print("System Type:                        " + str(n_classes) + "-way classifier")
                print("Best-guess accuracy:                {:.2f}%".format(randguess))
                print("Model accuracy:                     {:.2f}%".format(modelacc) + " (" + str(int(num_correct)) + "/" + str(count) + " correct)")
                print("Improvement over best guess:        {:.2f}%".format(modelacc - randguess) + " (of possible " + str(round(100 - randguess, 2)) + "%)")
                print("Model capacity (MEC):               {:.0f} bits".format(model_cap))
                print("Generalization ratio:               {:.2f}".format(int(float(num_correct * 100) / model_cap) / 100.0 * H) + " bits/bit")
                print("Model efficiency:                   {:.2f}%/parameter".format(int(100 * (modelacc - randguess) / model_cap) / 100.0))

        try:
            import numpy as np # For numpy see: http://numpy.org
            from numpy import array
        except:
            print("Note: If you install numpy (https://www.numpy.org) and scipy (https://www.scipy.org) this predictor generates a confusion matrix")

        def confusion_matrix(y_true, y_pred, labels=None, sample_weight=None, normalize=None):
            #check for numpy/scipy is imported
            try:
                from scipy.sparse import coo_matrix #required for multiclass metrics
            except:
                print("Note: If you install scipy (https://www.scipy.org) this predictor generates a confusion matrix")
                sys.exit()
            # Compute confusion matrix to evaluate the accuracy of a classification.
            # By definition a confusion matrix :math:C is such that :math:C_{i, j}
            # is equal to the number of observations known to be in group :math:i and
            # predicted to be in group :math:j.
            # Thus in binary classification, the count of true negatives is
            # :math:C_{0,0}, false negatives is :math:C_{1,0}, true positives is
            # :math:C_{1,1} and false positives is :math:C_{0,1}.
            # Read more in the :ref:User Guide <confusion_matrix>.
            # Parameters
            # ----------
            # y_true : array-like of shape (n_samples,)
            # Ground truth (correct) target values.
            # y_pred : array-like of shape (n_samples,)
            # Estimated targets as returned by a classifier.
            # labels : array-like of shape (n_classes), default=None
            # List of labels to index the matrix. This may be used to reorder
            # or select a subset of labels.
            # If None is given, those that appear at least once
            # in y_true or y_pred are used in sorted order.
            # sample_weight : array-like of shape (n_samples,), default=None
            # Sample weights.
            # normalize : {'true', 'pred', 'all'}, default=None
            # Normalizes confusion matrix over the true (rows), predicted (columns)
            # conditions or all the population. If None, confusion matrix will not be
            # normalized.
            # Returns
            # -------
            # C : ndarray of shape (n_classes, n_classes)
            # Confusion matrix.
            # References
            # ----------
            if labels is None:
                labels = np.array(list(set(list(y_true.astype('int')))))
            else:
                labels = np.asarray(labels)
                if np.all([l not in y_true for l in labels]):
                    raise ValueError("At least one label specified must be in y_true")


            if sample_weight is None:
                sample_weight = np.ones(y_true.shape[0], dtype=np.int64)
            else:
                sample_weight = np.asarray(sample_weight)
            if y_true.shape[0]!=y_pred.shape[0]:
                raise ValueError("y_true and y_pred must be of the same length")

            if normalize not in ['true', 'pred', 'all', None]:
                raise ValueError("normalize must be one of {'true', 'pred', 'all', None}")


            n_labels = labels.size
            label_to_ind = {y: x for x, y in enumerate(labels)}
            # convert yt, yp into index
            y_pred = np.array([label_to_ind.get(x, n_labels + 1) for x in y_pred])
            y_true = np.array([label_to_ind.get(x, n_labels + 1) for x in y_true])
            # intersect y_pred, y_true with labels, eliminate items not in labels
            ind = np.logical_and(y_pred < n_labels, y_true < n_labels)
            y_pred = y_pred[ind]
            y_true = y_true[ind]
            # also eliminate weights of eliminated items
            sample_weight = sample_weight[ind]
            # Choose the accumulator dtype to always have high precision
            if sample_weight.dtype.kind in {'i', 'u', 'b'}:
                dtype = np.int64
            else:
                dtype = np.float64
            cm = coo_matrix((sample_weight, (y_true, y_pred)), shape=(n_labels, n_labels), dtype=dtype,).toarray()


            with np.errstate(all='ignore'):
                if normalize == 'true':
                    cm = cm / cm.sum(axis=1, keepdims=True)
                elif normalize == 'pred':
                    cm = cm / cm.sum(axis=0, keepdims=True)
                elif normalize == 'all':
                    cm = cm / cm.sum()
                cm = np.nan_to_num(cm)
            return cm
        mtrx = confusion_matrix(np.array(true_labels).reshape(-1), np.array(preds).reshape(-1))
        if args.json:
            json_dict['confusion_matrix'] = mtrx.tolist()
            print(json.dumps(json_dict))
        else:
            mtrx = mtrx / np.sum(mtrx) * 100.0
            print("Confusion Matrix:")
            print(' ' + np.array2string(mtrx, formatter={'float': (lambda x: '{:.2f}%'.format(round(float(x), 2)))})[1:-1])

    #Clean Up
    if not args.cleanfile:
        os.remove(cleanfile)
        if output!=-1:
            os.remove(preprocessedfile)
