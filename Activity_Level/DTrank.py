#!/usr/bin/env python3
#
# This code has been produced by a free evaluation version of Brainome Table Compiler(tm).
# Portions of this code copyright (c) 2019-2021 by Brainome, Inc. All Rights Reserved.
# Brainome grants an exclusive (subject to our continuing rights to use and modify models),
# worldwide, non-sublicensable, and non-transferable limited license to use and modify this
# predictor produced through the input of your data:
# (i) for users accessing the service through a free evaluation account, solely for your
# own non-commercial purposes, including for the purpose of evaluating this service, and
# (ii) for users accessing the service through a paid, commercial use account, for your
# own internal  and commercial purposes.
# Please contact support@brainome.ai with any questions.
# Use of predictions results at your own risk.
#
# Output of Brainome Table Compiler v0.991.
# Invocation: btc train.csv -headerless -f DT -rank -o DTrank.py -riskoverfit --yes
# Total compiler execution time: 0:03:25.59. Finished on: Mar-17-2021 05:23:19.
# This source code requires Python 3.
#
"""
Classifier Type:                    Decision Tree
System Type:                         6-way classifier
Best-guess accuracy:                 18.88%
Overall Model accuracy:              86.50% (4454/5149 correct)
Overall Improvement over best guess: 67.62% (of possible 81.12%)
Model capacity (MEC):                1182 bits
Generalization ratio:                9.69 bits/bit
Model efficiency:                    0.05%/parameter
Confusion Matrix:
 [14.84% 1.63% 0.21% 0.00% 0.00% 0.04%]
 [4.31% 10.35% 0.23% 0.00% 0.00% 0.10%]
 [1.32% 0.68% 11.65% 0.00% 0.00% 0.00%]
 [0.00% 0.00% 0.00% 15.94% 0.84% 0.47%]
 [0.00% 0.00% 0.00% 1.30% 17.09% 0.12%]
 [0.33% 0.68% 0.00% 0.78% 0.47% 16.62%]
Avg. noise resilience per instance:  -0.58dB
Percent of Data Memorized:           31.99%
Note: Unable to split dataset. The predictor was trained and evaluated on the same data.
{"to_select_idxs":[53, 366, 310, 388, 422], "to_ignore_idxs":[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 111, 112, 113, 114, 115, 116, 117, 118, 119, 120, 121, 122, 123, 124, 125, 126, 127, 128, 129, 130, 131, 132, 133, 134, 135, 136, 137, 138, 139, 140, 141, 142, 143, 144, 145, 146, 147, 148, 149, 150, 151, 152, 153, 154, 155, 156, 157, 158, 159, 160, 161, 162, 163, 164, 165, 166, 167, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 200, 201, 202, 203, 204, 205, 206, 207, 208, 209, 210, 211, 212, 213, 214, 215, 216, 217, 218, 219, 220, 221, 222, 223, 224, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 235, 236, 237, 238, 239, 240, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250, 251, 252, 253, 254, 255, 256, 257, 258, 259, 260, 261, 262, 263, 264, 265, 266, 267, 268, 269, 270, 271, 272, 273, 274, 275, 276, 277, 278, 279, 280, 281, 282, 283, 284, 285, 286, 287, 288, 289, 290, 291, 292, 293, 294, 295, 296, 297, 298, 299, 300, 301, 302, 303, 304, 305, 306, 307, 308, 309, 311, 312, 313, 314, 315, 316, 317, 318, 319, 320, 321, 322, 323, 324, 325, 326, 327, 328, 329, 330, 331, 332, 333, 334, 335, 336, 337, 338, 339, 340, 341, 342, 343, 344, 345, 346, 347, 348, 349, 350, 351, 352, 353, 354, 355, 356, 357, 358, 359, 360, 361, 362, 363, 364, 365, 367, 368, 369, 370, 371, 372, 373, 374, 375, 376, 377, 378, 379, 380, 381, 382, 383, 384, 385, 386, 387, 389, 390, 391, 392, 393, 394, 395, 396, 397, 398, 399, 400, 401, 402, 403, 404, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 417, 418, 419, 420, 421, 423, 424, 425, 426, 427, 428, 429, 430, 431, 432, 433, 434, 435, 436, 437, 438, 439, 440, 441, 442, 443, 444, 445, 446, 447, 448, 449, 450, 451, 452, 453, 454, 455, 456, 457, 458, 459, 460, 461, 462, 463, 464, 465, 466, 467, 468, 469, 470, 471, 472, 473, 474, 475, 476, 477, 478, 479, 480, 481, 482, 483, 484, 485, 486, 487, 488, 489, 490, 491, 492, 493, 494, 495, 496, 497, 498, 499, 500, 501, 502, 503, 504, 505, 506, 507, 508, 509, 510, 511, 512, 513, 514, 515, 516, 517, 518, 519, 520, 521, 522, 523, 524, 525, 526, 527, 528, 529, 530, 531, 532, 533, 534, 535, 536, 537, 538, 539, 540, 541, 542, 543, 544, 545, 546, 547, 548, 549, 550, 551, 552, 553, 554, 555, 556, 557, 558, 559, 560], "noncontributing_idxs":[], "overfit_risk":5.049880184815336e-05, "risk_progression":[23.232109931177696, 36.25393358851401, 32.73778906638591, 30.337558779129253, 30.775206954599152], "test_accuracy_progression":[[53, 0.5606913963876481], [366, 0.6127403379296951], [310, 0.6607108176344921], [388, 0.6628471547873374], [422, 0.6632355797242183]]}

"""

# Imports -- Python3 standard library
import sys
import math
import os
import argparse
import tempfile
import csv
import binascii
import faulthandler

# Imports -- external
try:
    import numpy as np # For numpy see: http://numpy.org
    from numpy import array
except:
    print("This predictor requires the Numpy library. For installation instructions please refer to: http://numpy.org")

# Magic constants follow
# I/O buffer for clean. Reduce this constant for low memory devices. 
IOBUF = 100000000

# Ugly workaround for large classifiers
sys.setrecursionlimit(1000000)

# Training file given to compiler
TRAINFILE = "train.csv"


#Number of attributes
num_attr = 5
n_classes = 6
transform_true = False

# Preprocessor for CSV files

ignorelabels=[]
ignorecolumns=["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260","261","262","263","264","265","266","267","268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288","289","290","291","292","293","294","295","296","297","298","299","300","301","302","303","304","305","306","307","308","309","311","312","313","314","315","316","317","318","319","320","321","322","323","324","325","326","327","328","329","330","331","332","333","334","335","336","337","338","339","340","341","342","343","344","345","346","347","348","349","350","351","352","353","354","355","356","357","358","359","360","361","362","363","364","365","367","368","369","370","371","372","373","374","375","376","377","378","379","380","381","382","383","384","385","386","387","389","390","391","392","393","394","395","396","397","398","399","400","401","402","403","404","405","406","407","408","409","410","411","412","413","414","415","416","417","418","419","420","421","423","424","425","426","427","428","429","430","431","432","433","434","435","436","437","438","439","440","441","442","443","444","445","446","447","448","449","450","451","452","453","454","455","456","457","458","459","460","461","462","463","464","465","466","467","468","469","470","471","472","473","474","475","476","477","478","479","480","481","482","483","484","485","486","487","488","489","490","491","492","493","494","495","496","497","498","499","500","501","502","503","504","505","506","507","508","509","510","511","512","513","514","515","516","517","518","519","520","521","522","523","524","525","526","527","528","529","530","531","532","533","534","535","536","537","538","539","540","541","542","543","544","545","546","547","548","549","550","551","552","553","554","555","556","557","558","559","560",]
target=""
important_idxs=[53,310,366,388,422]

def preprocess(inputcsvfile, outputcsvfile, headerless=False, testfile=False, target='', ignorecolumns=[], ignorelabels=[], trim=False):
    #This function streams in a csv and outputs a csv with the correct columns and target column on the right hand side. 
    #Precursor to clean

    il=[]

    ignorelabels=[]
    ignorecolumns=["0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20","21","22","23","24","25","26","27","28","29","30","31","32","33","34","35","36","37","38","39","40","41","42","43","44","45","46","47","48","49","50","51","52","54","55","56","57","58","59","60","61","62","63","64","65","66","67","68","69","70","71","72","73","74","75","76","77","78","79","80","81","82","83","84","85","86","87","88","89","90","91","92","93","94","95","96","97","98","99","100","101","102","103","104","105","106","107","108","109","110","111","112","113","114","115","116","117","118","119","120","121","122","123","124","125","126","127","128","129","130","131","132","133","134","135","136","137","138","139","140","141","142","143","144","145","146","147","148","149","150","151","152","153","154","155","156","157","158","159","160","161","162","163","164","165","166","167","168","169","170","171","172","173","174","175","176","177","178","179","180","181","182","183","184","185","186","187","188","189","190","191","192","193","194","195","196","197","198","199","200","201","202","203","204","205","206","207","208","209","210","211","212","213","214","215","216","217","218","219","220","221","222","223","224","225","226","227","228","229","230","231","232","233","234","235","236","237","238","239","240","241","242","243","244","245","246","247","248","249","250","251","252","253","254","255","256","257","258","259","260","261","262","263","264","265","266","267","268","269","270","271","272","273","274","275","276","277","278","279","280","281","282","283","284","285","286","287","288","289","290","291","292","293","294","295","296","297","298","299","300","301","302","303","304","305","306","307","308","309","311","312","313","314","315","316","317","318","319","320","321","322","323","324","325","326","327","328","329","330","331","332","333","334","335","336","337","338","339","340","341","342","343","344","345","346","347","348","349","350","351","352","353","354","355","356","357","358","359","360","361","362","363","364","365","367","368","369","370","371","372","373","374","375","376","377","378","379","380","381","382","383","384","385","386","387","389","390","391","392","393","394","395","396","397","398","399","400","401","402","403","404","405","406","407","408","409","410","411","412","413","414","415","416","417","418","419","420","421","423","424","425","426","427","428","429","430","431","432","433","434","435","436","437","438","439","440","441","442","443","444","445","446","447","448","449","450","451","452","453","454","455","456","457","458","459","460","461","462","463","464","465","466","467","468","469","470","471","472","473","474","475","476","477","478","479","480","481","482","483","484","485","486","487","488","489","490","491","492","493","494","495","496","497","498","499","500","501","502","503","504","505","506","507","508","509","510","511","512","513","514","515","516","517","518","519","520","521","522","523","524","525","526","527","528","529","530","531","532","533","534","535","536","537","538","539","540","541","542","543","544","545","546","547","548","549","550","551","552","553","554","555","556","557","558","559","560",]
    target=""
    important_idxs=[53,310,366,388,422]
    if ignorelabels == [] and ignorecolumns == [] and target == "":
        return -1
    if not trim:
        ignorecolumns = []
    if (testfile):
        target = ''
        hc = -1 
    with open(outputcsvfile, "w+", encoding='utf-8') as outputfile:
        with open(inputcsvfile, "r", encoding='utf-8') as csvfile:      # hardcoded utf-8 encoding per #717
            reader = csv.reader(csvfile)
            if (headerless == False):
                header=next(reader, None)
                try:
                    if not testfile:
                        if (target != ''): 
                            hc = header.index(target)
                        else:
                            hc = len(header) - 1
                            target=header[hc]
                except:
                    raise NameError("Target '" + target + "' not found! Header must be same as in file passed to btc.")
                for i in range(0, len(ignorecolumns)):
                    try:
                        col = header.index(ignorecolumns[i])
                        if not testfile:
                            if (col == hc):
                                raise ValueError("Attribute '" + ignorecolumns[i] + "' is the target. Header must be same as in file passed to btc.")
                        il = il + [col]
                    except ValueError:
                        raise
                    except:
                        raise NameError("Attribute '" + ignorecolumns[i] + "' not found in header. Header must be same as in file passed to btc.")
                first = True
                for i in range(0, len(header)):

                    if (i == hc):
                        continue
                    if (i in il):
                        continue
                    if first:
                        first = False
                    else:
                        print(",", end='', file=outputfile)
                    print(header[i], end='', file=outputfile)
                if not testfile:
                    print("," + header[hc], file=outputfile)
                else:
                    print("", file=outputfile)

                for row in csv.DictReader(open(inputcsvfile, encoding='utf-8')):
                    if target and (row[target] in ignorelabels):
                        continue
                    first = True
                    for name in header:
                        if (name in ignorecolumns):
                            continue
                        if (name == target):
                            continue
                        if first:
                            first = False
                        else:
                            print(",", end='', file=outputfile)
                        if (',' in row[name]):
                            print('"' + row[name].replace('"', '') + '"', end='', file=outputfile)
                        else:
                            print(row[name].replace('"', ''), end='', file=outputfile)
                    if not testfile:
                        print("," + row[target], file=outputfile)
                    else:
                        if len(important_idxs) == 1:
                            print(",", file=outputfile)
                        else:
                            print("", file=outputfile)

            else:
                try:
                    if (target != ""): 
                        hc = int(target)
                    else:
                        hc = -1
                except:
                    raise NameError("No header found but attribute name given as target. Header must be same as in file passed to btc.")
                for i in range(0, len(ignorecolumns)):
                    try:
                        col = int(ignorecolumns[i])
                        if (col == hc):
                            raise ValueError("Attribute " + str(col) + " is the target. Cannot ignore. Header must be same as in file passed to btc.")
                        il = il + [col]
                    except ValueError:
                        raise
                    except:
                        raise ValueError("No header found but attribute name given in ignore column list. Header must be same as in file passed to btc.")
                for row in reader:
                    first = True
                    if (hc == -1) and (not testfile):
                        hc = len(row) - 1
                    if (row[hc] in ignorelabels):
                        continue
                    for i in range(0, len(row)):
                        if (i in il):
                            continue
                        if (i == hc):
                            continue
                        if first:
                            first = False
                        else:
                            print(",", end='', file=outputfile)
                        if (',' in row[i]):
                            print('"' + row[i].replace('"', '') + '"', end='', file=outputfile)
                        else:
                            print(row[i].replace('"', ''), end = '', file=outputfile)
                    if not testfile:
                        print("," + row[hc], file=outputfile)
                    else:
                        if len(important_idxs) == 1:
                            print(",", file=outputfile)
                        else:
                            print("", file=outputfile)


def clean(filename, outfile, rounding=-1, headerless=False, testfile=False, trim=False):
    #This function takes a preprocessed csv and cleans it to real numbers for prediction or validation


    clean.classlist = []
    clean.testfile = testfile
    clean.mapping = {}
    

    def convert(cell):
        value = str(cell)
        try:
            result = int(value)
            return result
        except:
            try:
                result=float(value)
                if math.isnan(result):
                    #if nan parse to string
                    raise ValueError('')
                if (rounding != -1):
                    result = int(result * math.pow(10, rounding)) / math.pow(10, rounding)
                return result
            except:
                result = (binascii.crc32(value.encode('utf8')) % (1 << 32))
                return result

    #Function to return key for any value 
    def get_key(val, clean_classmapping):
        if clean_classmapping == {}:
            return val
        for key, value in clean_classmapping.items(): 
            if val == value:
                return key
        if val not in list(clean_classmapping.values):
            raise ValueError("Label key does not exist")


    #Function to convert the class label
    def convertclassid(cell):
        if (clean.testfile):
            return convert(cell)
        value = str(cell)
        if (value == ''):
            raise ValueError("All cells in the target column must contain a class label.")

        if (not clean.mapping == {}):
            result = -1
            try:
                result = clean.mapping[cell]
            except:
                raise ValueError("Class label '" + value + "' encountered in input not defined in user-provided mapping.")
            if (not result == int(result)):
                raise ValueError("Class labels must be mapped to integer.")
            if (not str(result) in clean.classlist):
                clean.classlist = clean.classlist + [str(result)]
            return result
        try:
            result = float(cell)
            if (rounding != -1):
                result = int(result * math.pow(10, rounding)) / math.pow(10, rounding)
            else:
                result = int(int(result * 100) / 100)  # round classes to two digits

            if (not str(result) in clean.classlist):
                clean.classlist = clean.classlist + [str(result)]
        except:
            result = (binascii.crc32(value.encode('utf8')) % (1 << 32))
            if (result in clean.classlist):
                result = clean.classlist.index(result)
            else:
                clean.classlist = clean.classlist + [result]
                result = clean.classlist.index(result)
            if (not result == int(result)):
                raise ValueError("Class labels must be mappable to integer.")
        finally:
            if (result < 0):
                raise ValueError("Integer class labels must be positive and contiguous.")

        return result


    #Main Cleaning Code
    rowcount = 0
    with open(filename, encoding='utf-8') as csv_file:
        reader = csv.reader(csv_file)
        f = open(outfile, "w+", encoding='utf-8')
        if (headerless == False):
            next(reader, None)
        outbuf = []
        for row in reader:
            if (row == []):  # Skip empty rows
                continue
            rowcount = rowcount + 1
            if not transform_true:
                rowlen = num_attr if trim else num_attr + len(ignorecolumns)
            else:
                rowlen = num_attr_before_transform if trim else num_attr_before_transform + len(ignorecolumns)      # noqa
            if (not testfile):
                rowlen = rowlen + 1    
            if ((len(row) - (1 if ((testfile and len(important_idxs) == 1)) else 0))  != rowlen) and not (row == ['','']):
                raise ValueError("Column count must match trained predictor. Row " + str(rowcount) + " differs. Expected Row length: " + str(rowlen) + ", Actual Row Length: " + str(len(row)))
            i = 0
            for elem in row:
                if(i + 1 < len(row)):
                    outbuf.append(str(convert(elem)))
                    outbuf.append(',')
                else:
                    classid = str(convertclassid(elem))
                    outbuf.append(classid)
                i = i + 1
            if (len(outbuf) < IOBUF):
                outbuf.append(os.linesep)
            else:
                print(''.join(outbuf), file=f)
                outbuf = []
        print(''.join(outbuf), end="", file=f)
        f.close()

        if (testfile == False and not len(clean.classlist) >= 2):
            raise ValueError("Number of classes must be at least 2.")

        return get_key, clean.mapping


# Calculate energy

# Imports -- external
import numpy as np # For numpy see: http://numpy.org
from numpy import array
energy_thresholds = array([-4.62, -4.5825, -4.5440000000000005, -4.52, -4.5045, -4.4765, -4.4355, -4.4345, -4.426, -4.420999999999999, -4.4105, -4.406, -4.4005, -4.398, -4.393, -4.3835, -4.3805, -4.377, -4.3755, -4.339, -4.3375, -4.3065, -4.3045, -4.297499999999999, -4.2940000000000005, -4.2835, -4.2825, -4.2745, -4.271, -4.211, -4.2095, -4.1905, -4.1895, -4.1615, -4.1605, -4.1355, -4.1345, -4.1265, -4.1255, -4.1205, -4.1195, -4.1065000000000005, -4.1055, -4.1035, -4.1025, -4.1015, -4.098750000000001, -4.0969, -4.0966000000000005, -4.0959, -4.09545, -4.0927, -4.0914, -4.09075, -4.09055, -4.08855, -4.08795, -4.08055, -4.08005, -4.0779499999999995, -4.07555, -4.07465, -4.0738, -4.073, -4.07115, -4.06115, -4.058949999999999, -4.0569500000000005, -4.04965, -4.0493500000000004, -4.0478000000000005, -4.047000000000001, -4.046799999999999, -4.0463000000000005, -4.04405, -4.0432500000000005, -4.0419, -4.0411, -4.0393, -4.03825, -4.0381, -4.0375, -4.03425, -4.03415, -4.034050000000001, -4.0322499999999994, -4.031599999999999, -4.0306999999999995, -4.0298, -4.02825, -4.02625, -4.02605, -4.02505, -4.02465, -4.024150000000001, -4.02365, -4.0194, -4.01875, -4.0175, -4.0169999999999995, -4.015700000000001, -4.0154499999999995, -4.01525, -4.01495, -4.0145, -4.0139499999999995, -4.01205, -4.01195, -4.010400000000001, -4.0100750000000005, -4.00943, -4.009005, -4.00895, -4.008884999999999, -4.00886, -4.005795, -4.005265, -4.005005, -4.004785, -4.004635, -4.004075, -4.00383, -4.002090000000001, -4.001965, -4.001670000000001, -4.000995, -4.000945, -4.00078, -3.9995900000000004, -3.99884, -3.9987649999999997, -3.99849, -3.9981400000000002, -3.99798, -3.9967449999999998, -3.9957149999999997, -3.9953, -3.99411, -3.992315, -3.99116, -3.9904900000000003, -3.9898000000000002, -3.98945, -3.98545, -3.98395, -3.9834500000000004, -3.98125, -3.98075, -3.9802, -3.9795999999999996, -3.9791499999999997, -3.97825, -3.9772000000000003, -3.9770000000000003, -3.9769, -3.9768, -3.9766, -3.9763, -3.97615, -3.97575, -3.97515, -3.9748, -3.9739, -3.9734499999999997, -3.97305, -3.97285, -3.97145, -3.9709000000000003, -3.9692, -3.9687, -3.9646999999999997, -3.9636, -3.9621500000000003, -3.96145, -3.9596999999999998, -3.9588, -3.95785, -3.9572000000000003, -3.9567, -3.9561, -3.95235, -3.9522500000000003, -3.9503000000000004, -3.949845, -3.949065, -3.94856, -3.9453, -3.9444, -3.9431000000000003, -3.94275, -3.9405, -3.9395, -3.9323, -3.9316500000000003, -3.9287500000000004, -3.9274500000000003, -3.9270500000000004, -3.9269, -3.92415, -3.92395, -3.92005, -3.9198, -3.91835, -3.9179500000000003, -3.91755, -3.91695, -3.915, -3.91465, -3.9141000000000004, -3.9137, -3.9135, -3.9116, -3.91075, -3.9105499999999997, -3.9088000000000003, -3.9081, -3.90585, -3.90545, -3.90235, -3.90185, -3.8956, -3.8951000000000002, -3.8895, -3.8880500000000002, -3.8873500000000005, -3.8870000000000005, -3.8805000000000005, -3.88, -3.8765, -3.8760000000000003, -3.87395, -3.873845, -3.858395, -3.8581950000000003, -3.8565, -3.8526000000000002, -3.84635, -3.8458, -3.8453, -3.840045, -3.838, -3.8366, -3.835, -3.8338, -3.8286999999999995, -3.82827, -3.8207, -3.819, -3.8164, -3.8155, -3.81325, -3.81255, -3.8109, -3.8104, -3.8095, -3.809, -3.8075, -3.8005000000000004, -3.8, -3.7977, -3.7971500000000002, -3.7956000000000003, -3.7947499999999996, -3.7931, -3.7925000000000004, -3.791, -3.78925, -3.78845, -3.78675, -3.78155, -3.7805, -3.7795, -3.7785, -3.7778, -3.77755, -3.7772500000000004, -3.7765500000000003, -3.7731, -3.7721, -3.7715, -3.7705, -3.7695, -3.7685000000000004, -3.76695, -3.7664999999999997, -3.7560000000000002, -3.7545, -3.7446, -3.7441, -3.7435, -3.7405, -3.7365, -3.734, -3.732925, -3.73205, -3.7306999999999997, -3.7302, -3.728, -3.7265, -3.7255000000000003, -3.7245, -3.724, -3.7234999999999996, -3.72175, -3.7205, -3.71975, -3.7192499999999997, -3.680535, -3.6790000000000003, -3.6769999999999996, -3.67575, -3.6748000000000003, -3.67366, -3.6725000000000003, -3.67112, -3.67065, -3.6695, -3.6655, -3.665, -3.6525, -3.6510000000000002, -3.6430000000000002, -3.6420000000000003, -3.636835, -3.636335, -3.635405, -3.634405, -3.633, -3.63195, -3.63095, -3.6285, -3.624, -3.6225000000000005, -3.5965, -3.5955, -3.5949549999999997, -3.5927499999999997, -3.59125, -3.5905, -3.5895, -3.588615, -3.587615, -3.585, -3.5806000000000004, -3.5801000000000003, -3.576, -3.5749000000000004, -3.5725, -3.5715000000000003, -3.5705, -3.5695, -3.5685000000000002, -3.5675, -3.5656999999999996, -3.5652, -3.56075, -3.56025, -3.5576499999999998, -3.5566500000000003, -3.5555, -3.5545, -3.5475000000000003, -3.5435, -3.5355, -3.5335, -3.5305, -3.5227500000000003, -3.52225, -3.5201000000000002, -3.5171, -3.5125, -3.5103999999999997, -3.499, -3.4975, -3.496, -3.4905, -3.4895, -3.487, -3.4835000000000003, -3.4825, -3.4796, -3.4791, -3.4745, -3.4715, -3.4695, -3.468, -3.4655, -3.4625, -3.4615, -3.4605499999999996, -3.45955, -3.4585, -3.4575, -3.4555, -3.451, -3.4435000000000002, -3.442, -3.439, -3.4385, -3.4375, -3.4355, -3.434, -3.4276, -3.4255999999999998, -3.4219999999999997, -3.4215, -3.4205, -3.417615, -3.413615, -3.4115, -3.4110000000000005, -3.3920000000000003, -3.3895, -3.388, -3.3795, -3.377, -3.3754999999999997, -3.3689999999999998, -3.36185, -3.36135, -3.3594999999999997, -3.358, -3.3419999999999996, -3.3409999999999997, -3.3223000000000003, -3.3205, -3.319, -3.3115, -3.31, -3.303, -3.2875, -3.2865, -3.2845, -3.279, -3.259, -3.257, -3.2409999999999997, -3.2405, -3.2149, -3.2144, -3.2104999999999997, -3.2095000000000002, -3.2090000000000005, -3.1935000000000002, -3.1925, -3.1675000000000004, -3.167, -3.1645000000000003, -3.1635, -3.0826000000000002, -3.0821, -3.0582000000000003, -3.0567, -3.0549, -3.0544000000000002, -3.05385, -3.05335, -3.04875, -3.04825, -3.0387500000000003, -3.0372500000000002, -3.0299500000000004, -3.0284500000000003, -3.01655, -3.01555, -3.00665, -3.00515, -2.9996, -2.9976000000000003, -2.98555, -2.98055, -2.97775, -2.97525, -2.954585, -2.9539999999999997, -2.9459999999999997, -2.9444999999999997, -2.9415, -2.9379999999999997, -2.9349999999999996, -2.9305000000000003, -2.926, -2.9215, -2.9155499999999996, -2.91455, -2.91115, -2.9074999999999998, -2.9055, -2.903, -2.8955, -2.894, -2.892, -2.8885, -2.8855, -2.8810000000000002, -2.876, -2.8745000000000003, -2.872, -2.8685, -2.859, -2.8576499999999996, -2.85715, -2.8516, -2.8495999999999997, -2.846, -2.8440000000000003, -2.8434999999999997, -2.842, -2.8325000000000005, -2.832, -2.8315, -2.8305, -2.8265000000000002, -2.8225, -2.8145, -2.8135000000000003, -2.8129999999999997, -2.811, -2.8095, -2.807, -2.8049999999999997, -2.8035, -2.802, -2.8, -2.7986500000000003, -2.795, -2.7937, -2.7931999999999997, -2.7925000000000004, -2.7915, -2.7837, -2.7822, -2.7805, -2.7777, -2.7735, -2.7714999999999996, -2.769, -2.76675, -2.76575, -2.7640000000000002, -2.7625, -2.7595, -2.7569999999999997, -2.75225, -2.74965, -2.74665, -2.74615, -2.7455, -2.7439999999999998, -2.7415000000000003, -2.7409999999999997, -2.7405, -2.739, -2.7375, -2.7359999999999998, -2.7344999999999997, -2.7329999999999997, -2.7285000000000004, -2.7275, -2.72295, -2.7224500000000003, -2.7215, -2.719, -2.7169999999999996, -2.7154999999999996, -2.70985, -2.7093499999999997, -2.7085, -2.7075, -2.7060500000000003, -2.7055, -2.7049, -2.7039, -2.7030000000000003, -2.6955, -2.6944999999999997, -2.6935000000000002, -2.6925, -2.692, -2.6899999999999995, -2.6875, -2.6845, -2.6834999999999996, -2.6814999999999998, -2.6795, -2.6785, -2.677, -2.6755, -2.6740000000000004, -2.6734999999999998, -2.672, -2.6710000000000003, -2.669, -2.6675, -2.6665, -2.6659499999999996, -2.6645, -2.659, -2.6580000000000004, -2.6574999999999998, -2.6555, -2.6505, -2.6494999999999997, -2.6470000000000002, -2.6464999999999996, -2.6435000000000004, -2.643, -2.6375, -2.6355, -2.6295, -2.628, -2.6265, -2.6254999999999997, -2.6239999999999997, -2.6216999999999997, -2.6212, -2.6174999999999997, -2.6165000000000003, -2.6155, -2.6135, -2.6125, -2.6098, -2.6093, -2.60895, -2.6084500000000004, -2.6079999999999997, -2.6065, -2.6025, -2.6015, -2.6005000000000003, -2.5985000000000005, -2.5965, -2.596, -2.5955, -2.5949999999999998, -2.594, -2.5919999999999996, -2.591, -2.5904999999999996, -2.5875, -2.5865, -2.5854999999999997, -2.5815, -2.5805, -2.5789999999999997, -2.5765000000000002, -2.5755, -2.5735, -2.5730000000000004, -2.5725, -2.572, -2.5709999999999997, -2.5700000000000003, -2.5675, -2.5664999999999996, -2.5635, -2.5625, -2.5615, -2.5595, -2.559, -2.5584999999999996, -2.5570000000000004, -2.55475, -2.55425, -2.5533, -2.5505, -2.5465, -2.54465, -2.5439999999999996, -2.5389999999999997, -2.5385, -2.5365, -2.5335, -2.5328999999999997, -2.53245, -2.53205, -2.5305, -2.5300000000000002, -2.5294999999999996, -2.5285, -2.527, -2.5265, -2.526, -2.5255, -2.5220000000000002, -2.5199999999999996, -2.5195, -2.5180499999999997, -2.5165499999999996, -2.51605, -2.5156, -2.5151000000000003, -2.5149999999999997, -2.5145, -2.5084999999999997, -2.5075, -2.50625, -2.5056, -2.5050999999999997, -2.5034, -2.5023999999999997, -2.5015, -2.5010000000000003, -2.50045, -2.49775, -2.49725, -2.4965, -2.4941000000000004, -2.4939999999999998, -2.4932, -2.4925, -2.4909999999999997, -2.4905, -2.4867500000000002, -2.48625, -2.4859999999999998, -2.48595, -2.4852, -2.4842500000000003, -2.4835000000000003, -2.4799999999999995, -2.4791, -2.4781000000000004, -2.4776499999999997, -2.47715, -2.4706, -2.4699999999999998, -2.4684999999999997, -2.46675, -2.46135, -2.46, -2.4559999999999995, -2.4555, -2.4524999999999997, -2.4515000000000002, -2.45, -2.4494999999999996, -2.4475, -2.4450000000000003, -2.4414999999999996, -2.4405, -2.43525, -2.4349999999999996, -2.4303, -2.4295, -2.4290000000000003, -2.4284999999999997, -2.4255, -2.4245, -2.4154999999999998, -2.415, -2.4139999999999997, -2.4137, -2.41295, -2.4124499999999998, -2.40875, -2.4082500000000002, -2.4080000000000004, -2.4078, -2.4065000000000003, -2.4059999999999997, -2.4050000000000002, -2.4044999999999996, -2.402, -2.4014999999999995, -2.3975, -2.3964999999999996, -2.395, -2.394, -2.3920500000000002, -2.3914999999999997, -2.3903, -2.3899999999999997, -2.3895, -2.3884999999999996, -2.3834999999999997, -2.3819999999999997, -2.3775, -2.3765, -2.3725, -2.3705, -2.3685, -2.3665000000000003, -2.3655, -2.3645, -2.36195, -2.36145, -2.357, -2.3555, -2.3549999999999995, -2.3529999999999998, -2.3520000000000003, -2.3507499999999997, -2.35025, -2.3495, -2.3484999999999996, -2.3475, -2.3470000000000004, -2.3415, -2.33805, -2.3369999999999997, -2.33285, -2.33245, -2.33215, -2.3320499999999997, -2.3295000000000003, -2.3287999999999998, -2.3283, -2.3265000000000002, -2.325, -2.3225, -2.3206499999999997, -2.32015, -2.3185000000000002, -2.3178, -2.31705, -2.3165000000000004, -2.3145, -2.3136, -2.3125, -2.3114999999999997, -2.3102, -2.3095, -2.3075, -2.3070000000000004, -2.3064999999999998, -2.3055, -2.3040000000000003, -2.3034999999999997, -2.3025, -2.3015, -2.3005, -2.2975000000000003, -2.29695, -2.295, -2.2935, -2.29275, -2.29225, -2.2915, -2.2904, -2.2894, -2.2885, -2.2805, -2.2795, -2.2786999999999997, -2.27825, -2.2765, -2.2755, -2.2750000000000004, -2.2735000000000003, -2.2715000000000005, -2.2695499999999997, -2.26905, -2.2685000000000004, -2.2664999999999997, -2.2649999999999997, -2.2634499999999997, -2.2619999999999996, -2.2616499999999995, -2.2605, -2.2596, -2.2584999999999997, -2.2575000000000003, -2.2569999999999997, -2.2565, -2.2550999999999997, -2.2541, -2.2526, -2.2521, -2.2493499999999997, -2.2474999999999996, -2.2459999999999996, -2.2455, -2.2445000000000004, -2.2435, -2.2424999999999997, -2.24175, -2.24125, -2.2385, -2.2365, -2.2329999999999997, -2.2319999999999998, -2.2285, -2.2278, -2.2234999999999996, -2.2225, -2.2195, -2.2184999999999997, -2.2125000000000004, -2.2117500000000003, -2.2095, -2.206, -2.2025, -2.2005, -2.19905, -2.1950000000000003, -2.1944999999999997, -2.1939, -2.1934, -2.1929, -2.1924, -2.18225, -2.18125, -2.1805, -2.1784999999999997, -2.1775, -2.176, -2.1708499999999997, -2.17035, -2.1695, -2.1689999999999996, -2.1685, -2.1679500000000003, -2.167, -2.1660500000000003, -2.1639999999999997, -2.1635, -2.1630000000000003, -2.1624999999999996, -2.15855, -2.15805, -2.15775, -2.1572500000000003, -2.1544999999999996, -2.1525, -2.15085, -2.1503500000000004, -2.149, -2.1479999999999997, -2.1464999999999996, -2.1455, -2.1449999999999996, -2.1435000000000004, -2.143, -2.1425, -2.1405000000000003, -2.1375, -2.135, -2.1334999999999997, -2.1319999999999997, -2.1315, -2.1189999999999998, -2.118, -2.1155, -2.1135, -2.1129499999999997, -2.1111, -2.11055, -2.11005, -2.1075, -2.10405, -2.1030499999999996, -2.1029999999999998, -2.1025, -2.1014999999999997, -2.1005000000000003, -2.0995, -2.0985, -2.0915, -2.0901, -2.0885, -2.0875000000000004, -2.0865, -2.0845000000000002, -2.0839999999999996, -2.0829999999999997, -2.08135, -2.0795, -2.0778499999999998, -2.07735, -2.075, -2.072, -2.068, -2.067, -2.0625, -2.0611, -2.0593000000000004, -2.0585, -2.0556, -2.0551000000000004, -2.048, -2.04455, -2.0435, -2.0372500000000002, -2.03625, -2.0359999999999996, -2.0349999999999997, -2.0335, -2.0324999999999998, -2.0313999999999997, -2.03, -2.0285, -2.0265, -2.0255, -2.0244999999999997, -2.0235, -2.0205, -2.0164999999999997, -2.0155, -2.0125, -2.011, -2.0096999999999996, -2.007, -2.0060000000000002, -2.0045, -2.0029000000000003, -2.0023999999999997, -2.0004999999999997, -1.9995, -1.9975, -1.9941, -1.992, -1.9905, -1.987, -1.9865, -1.986, -1.9849999999999999, -1.9838, -1.9809999999999999, -1.9719, -1.9714, -1.9700000000000002, -1.968, -1.9668999999999999, -1.9634999999999998, -1.9605000000000001, -1.9580000000000002, -1.9565000000000001, -1.9555, -1.9545000000000001, -1.9520000000000002, -1.9487999999999999, -1.9445000000000001, -1.9435, -1.9420000000000002, -1.9409999999999998, -1.9405, -1.9375, -1.9344999999999999, -1.9335, -1.9329999999999998, -1.9324999999999999, -1.9300000000000002, -1.9279, -1.9264999999999999, -1.9255000000000002, -1.9250000000000003, -1.924, -1.92275, -1.92225, -1.9215, -1.9205, -1.91425, -1.9095, -1.9075, -1.9060000000000001, -1.9041000000000001, -1.899, -1.8984999999999999, -1.8975, -1.896, -1.8923999999999999, -1.8904999999999998, -1.8855, -1.884, -1.8815, -1.8805, -1.87945, -1.8780000000000001, -1.8769999999999998, -1.8768999999999998, -1.8704999999999998, -1.8689999999999998, -1.86285, -1.86235, -1.8615, -1.8609999999999998, -1.858, -1.8545, -1.8505, -1.846, -1.8444999999999998, -1.843, -1.8379, -1.836, -1.8345, -1.8325, -1.8315, -1.826, -1.8215, -1.8195, -1.8175, -1.815, -1.8135, -1.8108499999999998, -1.80885, -1.8065, -1.8036999999999999, -1.8022, -1.8005, -1.7954999999999999, -1.7938, -1.7841, -1.7799999999999998, -1.7765, -1.7734999999999999, -1.7614999999999998, -1.7599999999999998, -1.7597999999999998, -1.75955, -1.7566, -1.75575, -1.7484499999999998, -1.7469999999999999, -1.7395, -1.7375, -1.736, -1.734, -1.7275, -1.724, -1.7229999999999999, -1.7205, -1.7185000000000001, -1.7165, -1.7105, -1.7075, -1.7065, -1.7055, -1.6995, -1.6965000000000001, -1.693, -1.6920000000000002, -1.6845, -1.6839000000000002, -1.6821000000000002, -1.6804000000000001, -1.67, -1.66855, -1.6680000000000001, -1.6629999999999998, -1.66115, -1.6589999999999998, -1.6575, -1.6568, -1.6563, -1.6540000000000001, -1.63895, -1.6369500000000001, -1.635, -1.6335, -1.6294999999999997, -1.6225, -1.5993, -1.5985, -1.58285, -1.5823, -1.5765, -1.5748, -1.569, -1.5659999999999998, -1.5565, -1.555, -1.5141499999999999, -1.5128199999999998, -1.5112999999999999, -1.509, -1.4055, -1.4039, -1.3943, -1.3928500000000001, -1.39005, -1.384, -1.37305, -1.3682500000000002, -1.3016, -1.2986499999999999, -1.2748, -1.2703, -1.1493, -1.1468, -0.5535, -0.472])
labels = array([3.0, 5.0, 3.0, 5.0, 4.0, 5.0, 4.0, 5.0, 4.0, 5.0, 4.0, 5.0, 4.0, 5.0, 4.0, 5.0, 4.0, 5.0, 4.0, 5.0, 4.0, 5.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 5.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 5.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 5.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 5.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 3.0, 4.0, 3.0, 5.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 5.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 4.0, 5.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 3.0, 5.0, 3.0, 4.0, 3.0, 4.0, 5.0, 3.0, 5.0, 4.0, 3.0, 5.0, 3.0, 4.0, 3.0, 5.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 3.0, 5.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 4.0, 3.0, 5.0, 4.0, 3.0, 5.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 4.0, 3.0, 5.0, 3.0, 4.0, 3.0, 5.0, 3.0, 4.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 4.0, 5.0, 3.0, 4.0, 3.0, 5.0, 3.0, 4.0, 5.0, 3.0, 4.0, 3.0, 5.0, 3.0, 5.0, 4.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 4.0, 3.0, 5.0, 3.0, 4.0, 5.0, 3.0, 5.0, 3.0, 4.0, 5.0, 4.0, 5.0, 3.0, 5.0, 4.0, 5.0, 3.0, 5.0, 3.0, 5.0, 4.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 4.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 4.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 4.0, 3.0, 4.0, 5.0, 3.0, 4.0, 5.0, 3.0, 5.0, 3.0, 5.0, 4.0, 5.0, 4.0, 5.0, 3.0, 5.0, 3.0, 4.0, 5.0, 4.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 4.0, 5.0, 3.0, 4.0, 5.0, 3.0, 5.0, 3.0, 5.0, 3.0, 5.0, 1.0, 5.0, 1.0, 5.0, 1.0, 5.0, 1.0, 5.0, 1.0, 5.0, 0.0, 5.0, 1.0, 5.0, 1.0, 5.0, 4.0, 5.0, 1.0, 5.0, 0.0, 5.0, 1.0, 5.0, 1.0, 5.0, 1.0, 5.0, 1.0, 0.0, 1.0, 5.0, 1.0, 5.0, 1.0, 0.0, 1.0, 5.0, 1.0, 5.0, 0.0, 1.0, 5.0, 1.0, 5.0, 1.0, 5.0, 0.0, 5.0, 1.0, 5.0, 0.0, 1.0, 0.0, 1.0, 5.0, 0.0, 5.0, 1.0, 5.0, 1.0, 5.0, 1.0, 0.0, 1.0, 5.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 5.0, 1.0, 0.0, 1.0, 0.0, 5.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 5.0, 1.0, 0.0, 1.0, 5.0, 1.0, 5.0, 1.0, 0.0, 1.0, 0.0, 1.0, 5.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 5.0, 0.0, 1.0, 0.0, 1.0, 0.0, 5.0, 1.0, 0.0, 5.0, 1.0, 2.0, 0.0, 1.0, 0.0, 1.0, 5.0, 1.0, 0.0, 1.0, 0.0, 1.0, 5.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 5.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 5.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 5.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 1.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 5.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 2.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 1.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 2.0, 1.0, 0.0, 2.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 2.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 2.0, 0.0, 1.0, 0.0, 1.0, 0.0, 1.0, 2.0, 1.0, 2.0, 1.0, 2.0, 0.0, 2.0, 1.0, 0.0, 2.0, 0.0, 1.0, 2.0, 0.0, 1.0, 2.0, 0.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 2.0, 1.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 1.0, 0.0, 2.0, 1.0, 0.0, 2.0, 0.0, 1.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 2.0, 1.0, 0.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 0.0, 1.0, 2.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 1.0, 2.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 1.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 1.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0, 0.0, 2.0])
def eqenergy(rows):
    try:
        return np.sum(rows, axis=1, dtype=np.float128)
    except:
        return np.sum(rows, axis=1, dtype=np.longdouble)
def classify(rows):
    energys = eqenergy(rows)

    def thresh_search(input_energys):
        numers = np.searchsorted(energy_thresholds, input_energys, side='left')-1
        indys = np.argwhere(np.logical_and(numers<=len(energy_thresholds), numers>=0)).reshape(-1)
        defaultindys = np.argwhere(np.logical_not(np.logical_and(numers<=len(energy_thresholds), numers>=0))).reshape(-1)
        outputs = np.zeros(input_energys.shape[0])
        outputs[indys] = labels[numers[indys]]
        if list(defaultindys):
            outputs[defaultindys] = 5
        return outputs
    return thresh_search(energys)

numthresholds = 1182

# Main method
model_cap = numthresholds


def Validate(file):
    #Load Array
    cleanarr = np.loadtxt(file, delimiter=',', dtype='float64')


    if n_classes == 2:
        #note that classification is a single line of code
        outputs = classify(cleanarr[:, :-1])


        #metrics
        count, correct_count, num_TP, num_TN, num_FP, num_FN, num_class_1, num_class_0 = 0, 0, 0, 0, 0, 0, 0, 0
        correct_count = int(np.sum(outputs.reshape(-1) == cleanarr[:, -1].reshape(-1)))
        count = outputs.shape[0]
        num_TP = int(np.sum(np.logical_and(outputs.reshape(-1) == 1, cleanarr[:, -1].reshape(-1) == 1)))
        num_TN = int(np.sum(np.logical_and(outputs.reshape(-1) == 0, cleanarr[:, -1].reshape(-1) == 0)))
        num_FN = int(np.sum(np.logical_and(outputs.reshape(-1) == 0, cleanarr[:, -1].reshape(-1) == 1)))
        num_FP = int(np.sum(np.logical_and(outputs.reshape(-1) == 1, cleanarr[:, -1].reshape(-1) == 0)))
        num_class_0 = int(np.sum(cleanarr[:, -1].reshape(-1) == 0))
        num_class_1 = int(np.sum(cleanarr[:, -1].reshape(-1) == 1))
        return count, correct_count, num_TP, num_TN, num_FP, num_FN, num_class_1, num_class_0, outputs, cleanarr[:, -1]


    else:
        #validation
        outputs = classify(cleanarr[:, :-1])


        #metrics
        count, correct_count = 0, 0
        numeachclass = {}
        for k, o in enumerate(outputs):
            if int(o) == int(float(cleanarr[k, -1])):
                correct_count += 1
            if int(float(cleanarr[k, -1])) in numeachclass.keys():
                numeachclass[int(float(cleanarr[k, -1]))] += 1
            else:
                numeachclass[int(float(cleanarr[k, -1]))] = 1
            count += 1
        return count, correct_count, numeachclass, outputs, cleanarr[:, -1]


#Predict on unlabeled data
def Predict(file, get_key, headerless, preprocessedfile, classmapping, trim=False):
    cleanarr = np.loadtxt(file, delimiter=',', dtype='float64')
    cleanarr = cleanarr.reshape(cleanarr.shape[0], -1)
    if not trim and ignorecolumns != []:
        cleanarr = cleanarr[:, important_idxs]
    with open(preprocessedfile, 'r', encoding='utf-8') as csvinput:
        dirtyreader = csv.reader(csvinput)
        if not headerless:
            header = next(dirtyreader, None)
        #print original header
        if (not headerless):
            print(','.join(header + ["Prediction"]))

        outputs = classify(cleanarr)

        for k, row in enumerate(dirtyreader):
            if k >= outputs.shape[0]:
                continue
            print(str(','.join(str(j) for j in (['"' + i + '"' if ',' in i else i for i in row]))) + str(',' if len(important_idxs) != 1 else '') + str(get_key(int(outputs[k]), classmapping)))
                




#Main
if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Predictor trained on '+TRAINFILE)
    parser.add_argument('csvfile', type=str, help='CSV file containing test set (unlabeled).')
    parser.add_argument('-validate', action='store_true', help='Validation mode. csvfile must be labeled. Output is classification statistics rather than predictions.')
    parser.add_argument('-cleanfile', action='store_true', help='Use this flag to save prediction time if the csvfile you are passing has already been preprocessed. Implies headerless.')
    parser.add_argument('-headerless', help='Do not treat the first line of csvfile as a header.', action='store_true')
    parser.add_argument('-json', action="store_true", default=False, help="report measurements as json")
    parser.add_argument('-trim', action="store_true", default=False, help="Output predictor file with only the selected important attributes (to be used with predictors built with -rank)")
    args = parser.parse_args()
    faulthandler.enable()


    if args.validate:
        args.trim = True


    #clean if not already clean
    if not args.cleanfile:
        cleanfile = tempfile.NamedTemporaryFile().name
        preprocessedfile = tempfile.NamedTemporaryFile().name
        output = preprocess(args.csvfile,preprocessedfile,args.headerless,(not args.validate), trim=args.trim)
        get_key, classmapping = clean(preprocessedfile if output!=-1 else args.csvfile, cleanfile, -1, args.headerless, (not args.validate), trim=args.trim)
    else:
        cleanfile=args.csvfile
        preprocessedfile=args.csvfile
        get_key = lambda x, y: x
        classmapping = {}
        output = None

    #Predict or Validate?
    if not args.validate:
        Predict(cleanfile, get_key, args.headerless, preprocessedfile if output!=-1 else args.csvfile, classmapping, trim=args.trim)


    else:
        classifier_type = 'DT'
        if n_classes == 2:
            count, correct_count, num_TP, num_TN, num_FP, num_FN, num_class_1, num_class_0, preds, true_labels = Validate(cleanfile)
        else:
            count, correct_count, numeachclass, preds, true_labels = Validate(cleanfile)


        #validation report
        if args.json:
            import json
        if n_classes == 2:
            #Base metrics
            FN = float(num_FN) * 100.0 / float(count)
            FP = float(num_FP) * 100.0 / float(count)
            TN = float(num_TN) * 100.0 / float(count)
            TP = float(num_TP) * 100.0 / float(count)
            num_correct = correct_count

            #Calculated Metrics
            if int(num_TP + num_FN) != 0:
                TPR = num_TP / (num_TP + num_FN) # Sensitivity, Recall
            if int(num_TN + num_FP) != 0:
                TNR = num_TN / (num_TN + num_FP) # Specificity
            if int(num_TP + num_FP) != 0:
                PPV = num_TP / (num_TP + num_FP) # Recall
            if int(num_FN + num_TP) != 0:
                FNR = num_FN / (num_FN + num_TP) # Miss rate
            if int(2 * num_TP + num_FP + num_FN) != 0:
                FONE = 2 * num_TP / (2 * num_TP + num_FP + num_FN) # F1 Score
            if int(num_TP + num_FN + num_FP) != 0:
                TS = num_TP / (num_TP + num_FN + num_FP) # Critical Success Index
            #Best Guess Accuracy
            randguess = int(float(10000.0 * max(num_class_1, num_class_0)) / count) / 100.0
            #Model Accuracy
            classbalance = [float(num_class_0)/count, float(num_class_1)/count]
            H = float(-1.0 * sum([classbalance[i] * math.log(classbalance[i]) / math.log(2) for i in range(len(classbalance))]))

            modelacc = int(float(num_correct * 10000) / count) / 100.0
            #Report
            json_dict = {'instance_count':                        count ,
                         'classifier_type':                        classifier_type,
                         'classes':                            2 ,
                         'false_negative_instances':    num_FN ,
                         'false_positive_instances':    num_FP ,
                         'true_positive_instances':    num_TP ,
                         'true_negative_instances':    num_TN,
                         'false_negatives':                        FN ,
                         'false_positives':                        FP ,
                         'true_negatives':                        TN ,
                         'true_positives':                        TP ,
                         'number_correct':                        num_correct ,
                         'accuracy': {
                             'best_guess': randguess,
                             'improvement': modelacc-randguess,
                             'model_accuracy': modelacc,
                         },
                         'model_capacity':                        model_cap ,
                         'generalization_ratio':                int(float(num_correct * 100) / model_cap) * H/ 100.0,
                         'model_efficiency':                    int(100 * (modelacc - randguess) / model_cap) / 100.0,
                        'shannon_entropy_of_labels':           H,
                        'classbalance':                        classbalance}
            if classifier_type == 'NN':
                json_dict['capacity_utilized_by_nn'] = cap_utilized # noqa
            if args.json:
                pass
            else:
                if classifier_type == 'NN':
                    print("Classifier Type:                    Neural Network")
                elif classifier_type == 'RF':
                    print("Classifier Type:                    Random Forest")
                else:
                    print("Classifier Type:                    Decision Tree")
                print("System Type:                        Binary classifier")
                print("Best-guess accuracy:                {:.2f}%".format(randguess))
                print("Model accuracy:                     {:.2f}%".format(modelacc) + " (" + str(int(num_correct)) + "/" + str(count) + " correct)")
                print("Improvement over best guess:        {:.2f}%".format(modelacc - randguess) + " (of possible " + str(round(100 - randguess, 2)) + "%)")
                print("Model capacity (MEC):               {:.0f} bits".format(model_cap))
                if classifier_type == 'NN':
                    print("Model Capacity Utilized:            {:.0f} bits".format(cap_utilized)) # noqa
                print("Generalization ratio:               {:.2f}".format(int(float(num_correct * 100) / model_cap) / 100.0 * H) + " bits/bit")
                print("Model efficiency:                   {:.2f}%/parameter".format(int(100 * (modelacc - randguess) / model_cap) / 100.0))
                print("System behavior")
                print("True Negatives:                     {:.2f}%".format(TN) + " (" + str(int(num_TN)) + "/" + str(count) + ")")
                print("True Positives:                     {:.2f}%".format(TP) + " (" + str(int(num_TP)) + "/" + str(count) + ")")
                print("False Negatives:                    {:.2f}%".format(FN) + " (" + str(int(num_FN)) + "/" + str(count) + ")")
                print("False Positives:                    {:.2f}%".format(FP) + " (" + str(int(num_FP)) + "/" + str(count) + ")")
                if int(num_TP + num_FN) != 0:
                    print("True Pos. Rate/Sensitivity/Recall:  {:.2f}".format(TPR))
                if int(num_TN + num_FP) != 0:
                    print("True Neg. Rate/Specificity:         {:.2f}".format(TNR))
                if int(num_TP + num_FP) != 0:
                    print("Precision:                          {:.2f}".format(PPV))
                if int(2 * num_TP + num_FP + num_FN) != 0:
                    print("F-1 Measure:                        {:.2f}".format(FONE))
                if int(num_TP + num_FN) != 0:
                    print("False Negative Rate/Miss Rate:      {:.2f}".format(FNR))
                if int(num_TP + num_FN + num_FP) != 0:
                    print("Critical Success Index:             {:.2f}".format(TS))
        #Multiclass
        else:
            num_correct = correct_count
            modelacc = int(float(num_correct * 10000) / count) / 100.0
            randguess = round(max(numeachclass.values()) / sum(numeachclass.values()) * 100, 2)
            classbalance = [float(numofcertainclass) / count for numofcertainclass in numeachclass.values()]
            H = float(-1.0 * sum([classbalance[i] * math.log(classbalance[i]) / math.log(2) for i in range(len(classbalance))]))

            if args.json:
                json_dict = {'instance_count':                        count,
                            'classifier_type':                        classifier_type,
                            'classes':                            n_classes,
                             'number_correct': num_correct,
                             'accuracy': {
                                 'best_guess': randguess,
                                 'improvement': modelacc - randguess,
                                 'model_accuracy': modelacc,
                             },
                             'model_capacity': model_cap,
                            'generalization_ratio':                int(float(num_correct * 100) / model_cap) / 100.0 * H,
                            'model_efficiency':                    int(100 * (modelacc - randguess) / model_cap) / 100.0,
                        'shannon_entropy_of_labels':           H,
                        'classbalance':                        classbalance}
                if classifier_type == 'NN':
                    json_dict['capacity_utilized_by_nn'] = cap_utilized # noqa
            else:
                if classifier_type == 'NN':
                    print("Classifier Type:                    Neural Network")
                elif classifier_type == 'RF':
                    print("Classifier Type:                    Random Forest")
                else:
                    print("Classifier Type:                    Decision Tree")
                print("System Type:                        " + str(n_classes) + "-way classifier")
                print("Best-guess accuracy:                {:.2f}%".format(randguess))
                print("Model accuracy:                     {:.2f}%".format(modelacc) + " (" + str(int(num_correct)) + "/" + str(count) + " correct)")
                print("Improvement over best guess:        {:.2f}%".format(modelacc - randguess) + " (of possible " + str(round(100 - randguess, 2)) + "%)")
                print("Model capacity (MEC):               {:.0f} bits".format(model_cap))
                if classifier_type == 'NN':
                    print("Model Capacity Utilized:            {:.0f} bits".format(cap_utilized)) # noqa              
                print("Generalization ratio:               {:.2f}".format(int(float(num_correct * 100) / model_cap) / 100.0 * H) + " bits/bit")
                print("Model efficiency:                   {:.2f}%/parameter".format(int(100 * (modelacc - randguess) / model_cap) / 100.0))

        try:
            import numpy as np # For numpy see: http://numpy.org
            from numpy import array
        except:
            print("Note: If you install numpy (https://www.numpy.org) and scipy (https://www.scipy.org) this predictor generates a confusion matrix")

        def confusion_matrix(y_true, y_pred, json, labels=None, sample_weight=None, normalize=None):
            stats = {}
            if labels is None:
                labels = np.array(list(set(list(y_true.astype('int')))))
            else:
                labels = np.asarray(labels)
                if np.all([l not in y_true for l in labels]):
                    raise ValueError("At least one label specified must be in y_true")
            n_labels = labels.size

            for class_i in range(n_labels):
                stats[class_i] = {'TP':{},'FP':{},'FN':{},'TN':{}}
                class_i_indices = np.argwhere(y_true==class_i) #indices with bus(call class_i=bus in this example)
                not_class_i_indices = np.argwhere(y_true!=class_i) #indices with not bus
                stats[int(class_i)]['TP'] = int(np.sum(y_pred[class_i_indices] == class_i)) #indices where bus, and we predict == bus
                stats[int(class_i)]['FN'] = int(np.sum(y_pred[class_i_indices] != class_i)) #indices where bus, and we predict != bus
                stats[int(class_i)]['TN'] = int(np.sum(y_pred[not_class_i_indices] != class_i)) #indices with not bus, where we predict != bus
                stats[int(class_i)]['FP'] = int(np.sum(y_pred[not_class_i_indices] == class_i)) #indices where not bus, we predict as bus
            #check for numpy/scipy is imported
            try:
                from scipy.sparse import coo_matrix #required for multiclass metrics
            except:
                if not json:
                    print("Note: If you install scipy (https://www.scipy.org) this predictor generates a confusion matrix")
                    sys.exit()
                else:
                    return np.array([]), stats
                

            # Compute confusion matrix to evaluate the accuracy of a classification.
            # By definition a confusion matrix :math:C is such that :math:C_{i, j}
            # is equal to the number of observations known to be in group :math:i and
            # predicted to be in group :math:j.
            # Thus in binary classification, the count of true negatives is
            # :math:C_{0,0}, false negatives is :math:C_{1,0}, true positives is
            # :math:C_{1,1} and false positives is :math:C_{0,1}.
            # Read more in the :ref:User Guide <confusion_matrix>.
            # Parameters
            # ----------
            # y_true : array-like of shape (n_samples,)
            # Ground truth (correct) target values.
            # y_pred : array-like of shape (n_samples,)
            # Estimated targets as returned by a classifier.
            # labels : array-like of shape (n_classes), default=None
            # List of labels to index the matrix. This may be used to reorder
            # or select a subset of labels.
            # If None is given, those that appear at least once
            # in y_true or y_pred are used in sorted order.
            # sample_weight : array-like of shape (n_samples,), default=None
            # Sample weights.
            # normalize : {'true', 'pred', 'all'}, default=None
            # Normalizes confusion matrix over the true (rows), predicted (columns)
            # conditions or all the population. If None, confusion matrix will not be
            # normalized.
            # Returns
            # -------
            # C : ndarray of shape (n_classes, n_classes)
            # Confusion matrix.
            # References
            # ----------



            if sample_weight is None:
                sample_weight = np.ones(y_true.shape[0], dtype=np.int64)
            else:
                sample_weight = np.asarray(sample_weight)
            if y_true.shape[0]!=y_pred.shape[0]:
                raise ValueError("y_true and y_pred must be of the same length")

            if normalize not in ['true', 'pred', 'all', None]:
                raise ValueError("normalize must be one of {'true', 'pred', 'all', None}")


            label_to_ind = {y: x for x, y in enumerate(labels)}
            # convert yt, yp into index
            y_pred = np.array([label_to_ind.get(x, n_labels + 1) for x in y_pred])
            y_true = np.array([label_to_ind.get(x, n_labels + 1) for x in y_true])
            # intersect y_pred, y_true with labels, eliminate items not in labels
            ind = np.logical_and(y_pred < n_labels, y_true < n_labels)
            y_pred = y_pred[ind]
            y_true = y_true[ind]

            # also eliminate weights of eliminated items
            sample_weight = sample_weight[ind]
            # Choose the accumulator dtype to always have high precision
            if sample_weight.dtype.kind in {'i', 'u', 'b'}:
                dtype = np.int64
            else:
                dtype = np.float64
            cm = coo_matrix((sample_weight, (y_true, y_pred)), shape=(n_labels, n_labels), dtype=dtype,).toarray()


            with np.errstate(all='ignore'):
                if normalize == 'true':
                    cm = cm / cm.sum(axis=1, keepdims=True)
                elif normalize == 'pred':
                    cm = cm / cm.sum(axis=0, keepdims=True)
                elif normalize == 'all':
                    cm = cm / cm.sum()
                cm = np.nan_to_num(cm)
            return cm, stats
        mtrx, stats = confusion_matrix(np.array(true_labels).reshape(-1), np.array(preds).reshape(-1), args.json)
        if args.json:
            json_dict['confusion_matrix'] = mtrx.tolist()
            json_dict['multiclass_stats'] = stats
            print(json.dumps(json_dict))
        else:
            mtrx = mtrx / np.sum(mtrx) * 100.0
            print("Confusion Matrix:")
            print(' ' + np.array2string(mtrx, formatter={'float': (lambda x: '{:.2f}%'.format(round(float(x), 2)))})[1:-1])


    #remove tempfile if created
    if not args.cleanfile: 
        os.remove(cleanfile)
        if output!=-1:
            os.remove(preprocessedfile)
